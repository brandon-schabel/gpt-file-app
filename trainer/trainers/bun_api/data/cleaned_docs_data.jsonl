{"messages": [{"role": "system", "content": "You're a TypeScript expert and proficient in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The documentation provides instructions on handling binary data in an API. It explains how to encode and decode binary data using various methods such as base64, hex, and UTF-8. It also covers how to convert binary data into readable formats and vice versa. The documentation includes code examples that demonstrate the use of these methods."}, {"role": "assistant", "content": "This page is an introduction to working with binary data in JavaScript using Bun. Bun provides various data types\nBlobs can be created from string or binary parts and concatenated together. They can be read asynchronously in various formats like text, array buffer, or stream. Blobs are often used to represent files uploaded via a file input element.\n\nStreams are an important abstraction for working with binary data without loading it all into memory at once. Bun implements the Web APIs ReadableStream and WritableStream.\n\nConverting from one binary format to another is a common task. Various methods are available depending on the format, such as using Uint8Array, DataView, Buffer, TextDecoder, Array.from, or Blob.\n\nThere is a utility function in Bun for converting a readable stream to an array of chunks. Additionally, there are convenient functions for converting a readable stream to array buffer, text, or blob.\n\nThe usage of readable streams, buffers, text encoders, and other concepts are discussed in more detail in the API documentation."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and an expert in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/console instructions provide information on how to use the console object in JavaScript. The console object is used to log messages, debug code, and display information in the browser's console.\n\nTo log a message using the console object, you can use the `log` method. This method accepts any number of arguments and logs them to the console.\n\nThe console object also allows you to display information with different levels of severity. For example, you can use the `error` method to log an error message, the `warn` method to log a warning message, and the `info` method to log an information message.\n\nIn addition to logging messages, the console object provides other useful methods for debugging code. The `assert` method can be used to define assertions that will display an error message if the condition is false. The `trace` method logs a stack trace to help identify where a particular piece of code was called from.\n\nTo group related console messages together, you can use the `group` and `groupEnd` methods. These methods create collapsible groups in the console for better organization of the output.\n\nFinally, the console object also supports formatting and styling of the output. You can use the `%c` placeholder in the log message and provide CSS styles to format the text.\n\nIn summary, the console object in JavaScript is a powerful tool for logging messages, debugging code, and displaying information in the browser's console. It provides methods for logging messages with different severity levels, debugging code with assertions and stack traces, grouping related messages, and formatting the output with CSS styles."}, {"role": "assistant", "content": "In Bun, the console object can be used to sequentially read lines from user input. This is useful for implementing interactive programs. Here's an example of an addition calculator implemented using the console object:\n\n```typescript\nlet count = 0;\nfor await (const line of console) {\n  count += Number(line);\n}\n```\n\nYou can run the program by running the following command:\n\n```bash\n$ bun adder.ts\n```\n\nThis will start the addition calculator. You can then input numbers and see the running total displayed after each input."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expert knowledge in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The API for DNS allows users to programmatically manage their DNS settings. Users can create, retrieve, update, and delete DNS records. To access the DNS API, users need to authenticate with their API key. The API supports various DNS record types, including A, AAAA, CNAME, MX, TXT, and SRV. When creating or updating a DNS record, users need to provide the hostname, type, and value. They can also set the TTL (Time-to-Live) for the record. To retrieve a DNS record, users need to specify the record ID. To delete a DNS record, users need to provide the record ID as well. The API provides response codes and error messages for successful and unsuccessful requests."}, {"role": "assistant", "content": "Bun is a module that allows you to perform DNS resolution and lookup IP addresses of a given hostname. It supports three backends for DNS resolution: c-ares, system's non-blocking DNS resolver, and POSIX standard getaddrinfo function. You can choose a particular backend by specifying it as an option. The module provides a lookup function that returns the IP address of the hostname. You can also specify the IP address family (IPv4 or IPv6) as an option. The module also returns the time-to-live (TTL) value for the resolved IP address, when c-ares backend is used."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The docs/api/ffi instructions guide developers on how to use the foreign function interface (FFI) in their applications. The FFI allows developers to call functions from libraries written in other programming languages. It provides a way to define the interface for the functions and manage the data types involved.\n\nThe instructions explain how to work with the FFI, including how to define and load libraries, declare functions, and handle data types. Developers are shown how to specify the argument and return types for the functions they want to call, as well as how to pass and receive data between the application and the library.\n\nThe instructions also cover error handling and memory management when working with the FFI. Developers are advised on how to handle exceptions and deallocate memory after using the FFI functions.\n\nOverall, the docs/api/ffi instructions are a comprehensive guide for developers to effectively use the FFI in their applications, allowing for seamless integration with libraries written in other programming languages."}, {"role": "assistant", "content": "The built-in `ffi` module allows efficient calling of native libraries from JavaScript. It supports languages such as Zig, Rust, C/C++, C#, Nim, Kotlin, etc. Examples of usage in Zig and Rust are provided. The `ffi` module is approximately 2-6x faster than Node.js FFI according to benchmarks. The module handles the conversion of JavaScript types to native types and includes support for strings, function pointers, and memory management. Variations of code examples are provided for working with function pointers, callbacks, and pointers. It is important to ensure that the pointer size matches the expected size in the API being used.\nWhen passing a pointer to FFI functions, make sure to pass a pointer of equivalent size. In the provided code example, the `pixels` array is passed as a pointer to the `encode_png` function. To read the pointer value, you can use the `ptr` function.\n\nHere is an example:\n\n```typescript\nimport { dlopen, FFIType, ptr } from \"bun:ffi\";\n\nconst {\n  symbols: { encode_png },\n} = dlopen(myLibraryPath, {\n  encode_png: {\n    args: [\"ptr\", \"u32\", \"u32\"],\n    returns: FFIType.ptr,\n  },\n});\n\nconst pixels = new Uint8ClampedArray(128 * 128 * 4);\npixels.fill(254);\n\nconst myPtr = ptr(pixels);\n\nconst out = encode_png(\n  myPtr,\n  128,\n  128,\n);\n```\n\nTo read the pointer value, assume it is 0-terminated and use the `toArrayBuffer` function to convert the returned value to a Uint8Array. You can then save the result to a file like this:\n\n```typescript\nlet png = new Uint8Array(toArrayBuffer(out));\nawait Bun.write(\"out.png\", png);\n```\n\n"}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The file I/O instructions in the Docs/api guide provide essential information for working with files in a program. It covers various aspects such as opening, reading, writing, and closing files using different modes. It explains the different file modes available, including read, write, append, and binary modes. The guide also includes examples of how to perform common file operations, such as reading a file line by line or writing data to a file. Additionally, it provides details on handling file errors and exceptions. Overall, it is a comprehensive resource for developers to understand and utilize file I/O operations effectively."}, {"role": "assistant", "content": "Bun provides optimized APIs for reading and writing files. The APIs are optimized for file-system tasks using Bun. You can create a file instance with the Bun.file() function, which represents a lazily-loaded file. You can read the contents of the file in various formats, such as a string, ReadableStream, or ArrayBuffer. File references can also be created using file descriptors or URLs. The file instance can point to a location on disk where a file does not exist. You can override the default MIME type by passing a second argument to Bun.file(). Convenience instances of stdin, stdout, and stderr are also available. For writing files, the write() function is used. It supports various types of data, including strings, Blobs, and Responses. It uses optimized system calls based on the platform. Bun also provides an incremental writing API called FileSink, which allows for buffered writing and flushing of data to disk. The FileSink can be used to incrementally write data to a file, flush the buffer to disk, and close the file. There is also an option to configure the high water mark for flushing the buffer. The write() function is benchmarked to be faster than the GNU cat command for large files on Linux."}]}
{"messages": [{"role": "system", "content": "You are adept in TypeScript and specialize in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/File System Router is a module that allows you to create a virtual file system in memory. You can use it to define routes for various paths and handle different actions like reading, writing, deleting, or listing files.\n\nTo start using the File System Router, you need to import the `fsr` module and create a new instance of the `FileSystemRouter` class. You can pass an optional root path to specify the starting directory of the virtual file system.\n\nThe File System Router provides several methods to define routes. The `addRoute` method lets you define a route for a specific path and map it to a handler function. The handler function will be called when a request is made to that path.\n\nYou can use wildcards in the route path to match multiple paths. For example, you can use `*` to match any single path segment, or `**` to match any number of path segments.\n\nThe `addReadRoute` method is a convenience method for defining a route for reading files. It automatically handles the file read operations and returns the contents of the file.\n\nSimilarly, the `addWriteRoute` method is used to define a route for writing files. It takes a handler function that will receive the file contents when a write request is made to that path.\n\nThe File System Router also provides methods for deleting files (`addDeleteRoute`) and listing files in a directory (`addListRoute`).\n\nOnce you have defined all the routes, you can start the router using the `start` method. This will start listening for incoming requests and invoke the appropriate handler function based on the requested path.\n\nOverall, the File System Router module provides a flexible and easy-to-use way to create a virtual file system and define custom routes for various file operations."}, {"role": "assistant", "content": "Bun is an API that resolves routes against file-system paths. It currently supports Next.js-style file-system routing. The Bun.FileSystemRouter class is used to resolve routes against a directory, and it accepts parameters such as the directory path, style, origin, and asset prefix. The match method of the router is used to match a given path and returns the file path, route kind, name, pathname, and source. It also parses query parameters and URL parameters, and returns them accordingly in the result. The router can be initialized with a Request or Response object as well. The reload method is used to rescan the files in the directory."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/file instructions provide an overview of how to work with files using the API. The instructions cover various operations such as uploading, downloading, and deleting files.\n\nTo upload a file, you need to make a POST request to the specified endpoint with the file data as a payload. The API will return a response with the file ID and other metadata.\n\nTo download a file, you need to make a GET request to the specified endpoint with the file ID as a parameter. The API will return the file data as the response.\n\nTo delete a file, you need to make a DELETE request to the specified endpoint with the file ID as a parameter. The API will delete the file and return a success response.\n\nOverall, the instructions provide the necessary information to effectively manage files using the API. It covers the basic operations of uploading, downloading, and deleting files."}, {"role": "assistant", "content": "Bun.js is a library that optimizes Web APIs for servers and CLIs with fast paths for common use cases. One key feature is the lazy loading of files, represented by a lazily-loaded file object. When passing a file blob to Bun.file(), it automatically uses a faster system call. For example, on Linux it uses the syscalls.read() and on macOS it uses syscalls.pread() or syscalls.read(). Bun.js also supports fetch objects and automatically converts them to a file object."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/globals instructions provide an overview of global variables and functions available in a programming language. These instructions list all the predefined global variables and functions and explain their purpose and usage. It also includes guidelines on how to use these globals effectively and provides examples to demonstrate their usage. By following these instructions, programmers can understand the built-in functionality of the language and leverage the available globals to write efficient and effective code."}, {"role": "assistant", "content": "Bun implements several globals, including:\n\n- Global: This global variable is used for general purposes.\n- Source: The source global variable is used specifically for web development.\n- Notes: This global variable is used for adding additional notes or comments.\n\n- Web: This global variable is intended for web development and can be used in command-line tools.\n- Node.js: This global variable is specific to Node.js and has a link for more information.\n- Bun: This global variable is specific to Bun and may change as additional APIs are added.\n\n- Cross-platform: This global variable aliases to another global variable.\n- Cloudflare: This global variable is related to Cloudflare services.\n- Stage 3 proposal: This global variable is part of a proposal in stage 3.\n\nNote: The remaining global variables have no specific information provided."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The docs/api/hashing instructions provide guidance on how to implement hashing algorithms in programming. Hashing involves transforming data into a fixed-length string of characters. The instructions cover various aspects, including choosing and initializing a hash function, creating a hash object, updating the hash with input data, and retrieving the resulting hash value. Different hashing algorithms such as MD5, SHA-1, and SHA-256 are explained, along with their strengths and weaknesses. Additionally, the instructions describe common use cases for hashing, such as password storage and data integrity verification. It is important to carefully select and securely manage hashing functions due to potential vulnerabilities such as collisions and brute-force attacks."}, {"role": "assistant", "content": "Bun is a library that provides utility functions for hashing and verifying passwords. It supports various cryptographically secure algorithms such as Argon2 and bcrypt. You can hash a password and verify it later using the `Bun.password.hash` and `Bun.password.verify` functions. You can also configure the hashing algorithm and parameters when generating the hash.\n\nThe library also includes non-cryptographic hashing algorithms for fast computation. You can use the `Bun.hash` function to generate a 64-bit hash from different types of input, including strings, arrays, and buffers. You can also specify an integer seed for the hash. Additional hashing algorithms like CRC32 and MurmurHash are available as properties on the `Bun.hash` object.\n\nFor incremental hash computation, you can use the `Bun.CryptoHasher` class. It supports various cryptographic hash algorithms such as SHA256. You can update the hash with data using the `update` method, and compute the final hash using the `digest` method. The hash can be returned as a Uint8Array or as a string in different encodings.\n\nIt's important to note that the synchronous versions of the functions are available but can impact application performance due to the computational complexity of hashing."}]}
{"messages": [{"role": "system", "content": "You have expertise in TypeScript and Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/html Rewriter instructions provide guidance on how to rewrite HTML content using the Cloudflare Workers HTMLRewriter API. It explains the core concepts of how the API works, such as element handlers and selectors, and provides example code snippets for different use cases. The instructions cover various scenarios, including modifying attributes, adding or removing elements, and transforming text. It also discusses customization options like filter options and argument passing. Overall, the Docs/api/html Rewriter instructions are a comprehensive resource for developers looking to manipulate HTML content using the Cloudflare Workers HTMLRewriter API."}, {"role": "assistant", "content": "Bun is a fast implementation of the HTML pattern developed by Cloudflare. It provides an API to traverse and transform HTML documents. Here is an example of how to use it:\n\n```ts\nconst rewriter = new HTMLRewriter();\nrewriter.on(\"\", {\n  element(el) {\n    console.log(el.tagName);\n  },\n});\n```\n\nTo parse and transform the HTML, you can use the `transform` method:\n\n```ts\nrewriter.transform(\n  new Response(`\n<!DOCTYPE html>\n<html>\n<!-- comment -->\n<head>\n  <title>My First HTML Page</title>\n</head>\n<body>\n  <h1>My First Heading</h1>\n  <p>My first paragraph.</p>\n</body>\n`));\n```\n\nFor more information, you can refer to the full documentation on the Cloudflare website."}]}
{"messages": [{"role": "system", "content": "You are a skilled TypeScript developer with expertise in TypeScript and extensive knowledge of buns."}, {"role": "user", "content": "The Docs/api/http instructions explain how to use the HTTP protocol in various scenarios. It covers the basics of sending HTTP requests and handling HTTP responses. The guidelines explain the different HTTP methods like GET, POST, PUT, and DELETE, and how to use them in API calls. It also provides information on headers, query parameters, and status codes. The instructions give examples of how to make API calls using different programming languages such as Python, Java, and Node.js. The content also explains how to handle authentication and authorization in HTTP requests."}, {"role": "assistant", "content": "The page documents the Bun-native API, which includes modules that have been re-implemented to use Bun's fast internal HTTP infrastructure. The page provides examples of how to start a high-performance HTTP server with Bun, handle incoming requests, and configure server settings like port and hostname. It also covers error handling, TLS configuration, hot-reloading syntax, streaming files, and includes benchmarks comparing Bun and Node.js performance. The page concludes with TypeScript definitions for the Bun module and the Server interface."}]}
{"messages": [{"role": "system", "content": "You excel in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The \"import Meta\" instructions in the API documentation are used to import metadata into a smart contract. This allows developers to access and use metadata information within their contracts. The metadata includes details such as the contract's name, version, and other information that can be useful for users and developers. To import the metadata, developers need to add the \"import Meta\" statement at the beginning of their smart contract code. This statement imports the necessary metadata functions and variables that can be referenced throughout the contract. By importing the Meta instructions, developers can enhance their smart contracts by providing additional information to users and enabling better interoperability with other contracts and services."}, {"role": "assistant", "content": "The  object in JavaScript is used by modules to access information about themselves. Each host (browser, runtime, etc) can have its own properties for the  object. In Bun, the following properties are implemented:\n\n1. `import.meta.dir`: Gives the absolute path to the directory containing the current file (e.g. \"/path/to/project\").\n2. `import.meta.file`: Provides the name of the current file.\n3. `import.meta.path`: Offers the absolute path to the current file.\n4. `import.meta.main`: Indicates if the current file is the entrypoint of the process. It is true if the file is directly executed, otherwise false.\n5. `import.meta.resolveSync`: Resolves a module specifier (e.g. \"zod\" or \"./file.tsx\") to an absolute path.\n\nHere are some examples of using `import.meta.resolveSync`:\n\n1. Resolving the \"zod\" module specifier: \n```ts\nimport.meta.resolveSync(\"zod\");\n// Returns: \"/path/to/project/node_modules/zod/index.ts\"\n```\n\n2. Resolving the \"./file.tsx\" module specifier:\n```ts\nimport.meta.resolveSync(\"./file.tsx\");\n// Returns: \"/path/to/project/file.tsx\"\n```\n\nNote: The contents of the  object may vary depending on the host environment."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Node.js API provides a set of built-in modules and functions that can be used for various purposes, such as file system operations, network operations, and HTTP requests. \n\nTo get started with the Node.js API, you need to install Node.js on your machine. Once installed, you can access the API by requiring the built-in modules in your JavaScript code.\n\nThe Node.js API includes modules like fs, http, and net. The fs module allows you to work with the file system, allowing you to read, write, and modify files and directories. The http module enables you to create an HTTP server or make HTTP requests to other servers. The net module allows you to create a TCP server or make TCP connections.\n\nIn addition to the built-in modules, the Node.js API also provides various utility functions, such as the util module, which contains functions for dealing with JavaScript objects and formatting strings. The events module provides a way to handle and trigger events, and the crypto module provides cryptographic functionality.\n\nTo use a module from the Node.js API, you need to import it using the `require` function. For example, to use the fs module, you would write `const fs = require('fs')`. Once imported, you can use the functions and properties exposed by the module.\n\nIn summary, the Node.js API provides a collection of built-in modules and functions that can be used for various purposes. To use the API, you need to install Node.js, require the desired modules, and then use the functions and properties provided by those modules."}, {"role": "assistant", "content": "Bun is a native add-on interface for Node.js, implementing 95% of the Node-API interface. This means that most existing Node-API extensions can be used with Bun without any modifications. The completion status of Bun can be tracked in this issue.\n\nIn Bun, Node-API modules can be required directly like in Node.js:\n```js\nconst napi = require(\"./my-node-module.node\");\n```\n\nAlternatively, you can use the following code snippet:\n```js\nlet mod = { exports: {} };\nprocess.dlopen(mod, \"./my-node-module.node\");\n```\n\nBun also polyfills the package, which is commonly used by Node-API modules to detect the correct binding to load."}]}
{"messages": [{"role": "system", "content": "You're a TypeScript expert."}, {"role": "user", "content": "The API docs for the `spawn` function provide instructions for its usage. The `spawn` function is used to create a new process in Node.js. It takes a command as a parameter and returns a `ChildProcess` object.\n\nTo use `spawn`, you need to require the `child_process` module first. Then you can call the `spawn` function, passing the command you want to execute as a string. Additional parameters can be passed as an array, which is useful for providing arguments to the command.\n\nThe `spawn` function returns a `ChildProcess` object, which includes properties and methods that allow you to interact with the running process. Some important properties include `stdin`, `stdout`, and `stderr`, which represent the standard input, standard output, and standard error streams of the child process.\n\nYou can listen for events on the `ChildProcess` object using the `on` method. For example, you can listen for the `exit` event to be notified when the process exits. You can also write data to the child process's standard input stream using the `stdin` property.\n\nIt's worth noting that the `spawn` function is asynchronous, so you may need to use callbacks or promises to handle the process's output or exit status.\n\nOverall, the `spawn` function in Node.js allows you to create and interact with child processes, providing a flexible way to execute commands and perform system tasks."}, {"role": "assistant", "content": "To spawn child processes in Bun, you can use the `spawn()` function. It takes a command as an array of strings and returns a `Subprocess` object. Additionally, you can pass a parameters object as the second argument to configure the subprocess.\n\nHere is an example of spawning a child process:\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"echo\", \"hello\"]);\n```\n\nYou can configure the input stream of the subprocess by setting the `stdin` parameter. By default, the input stream is undefined.\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"cat\"], {\n  stdin: await fetch(\"https://raw.githubusercontent.com/oven-sh/bun/main/examples/hashing.js\"),\n});\n```\n\nTo configure the output streams, you can use the `stdout` and `stderr` properties of the `Subprocess` object.\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"echo\", \"hello\"]);\n\nconst text = await new Response(proc.stdout).text();\nconsole.log(text); // \"hello\"\n```\n\nYou can listen for the process exiting or being killed using the `onExit` callback.\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"echo\", \"hello\"], {\n  onExit(proc, exitCode, signalCode, error) {\n    // exit handler\n  },\n});\n```\n\nTo kill a process, you can use the `kill()` method of the `Subprocess` object.\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"echo\", \"hello\"]);\nproc.kill();\n```\n\nThe parent process will not terminate until all child processes have exited. You can use the `unref()` method to detach the child process from the parent.\n\n```ts\nimport { spawn } from 'bun';\n\nconst proc = spawn([\"echo\", \"hello\"]);\nproc.unref();\n```\n\nBun also provides a synchronous equivalent of `spawn()` called `spawnSync()`. It returns a `SyncSubprocess` object, which blocks the execution until the subprocess completes.\n\n```ts\nimport { spawnSync } from 'bun';\n\nconst proc = spawnSync([\"echo\", \"hello\"]);\nconsole.log(proc.stdout.toString());\n```\nThese are the main features of spawning child processes in Bun. You can find more details and variations in the official documentation."}]}
{"messages": [{"role": "system", "content": "You are a TypeScript expert."}, {"role": "user", "content": "The SQLite module in the Python standard library provides a simple way to interact with SQLite databases. To use it, you need to import the `sqlite3` module.\n\nTo connect to a SQLite database, you need to use the `connect()` function from the `sqlite3` module, passing it the path to the database file. This function returns a connection object which you can use to execute SQL commands.\n\nOnce you have a connection object, you can create a cursor object using the `cursor()` method. The cursor object will allow you to execute SQL statements and fetch the results.\n\nTo execute an SQL statement, you can use the `execute()` method of the cursor object. You can pass the SQL statement as a string to this method. The `execute()` method can be used to execute any SQL statement, including SELECT, INSERT, UPDATE, and DELETE.\n\nAfter executing a SELECT statement, you can use the `fetchone()` method or the `fetchall()` method of the cursor object to fetch the results. The `fetchone()` method fetches one row at a time, while the `fetchall()` method fetches all rows at once.\n\nTo insert data into a SQLite table, you can use the `execute()` method with an INSERT statement. You need to provide the values for each column in the table using the `VALUES` clause.\n\nTo update data in a SQLite table, you can use the `execute()` method with an UPDATE statement. You need to specify which rows to update using the `WHERE` clause.\n\nTo delete data from a SQLite table, you can use the `execute()` method with a DELETE statement. You need to specify which rows to delete using the `WHERE` clause.\n\nAfter you are done with a cursor object, you should close it using the `close()` method.\n\nTo commit the changes made to the database, you can call the `commit()` method of the connection object.\n\nIf any errors occur while executing SQL statements, SQLite will raise an exception. You can use try-except blocks to catch these exceptions and handle them appropriately.\n\nTo learn more about the SQLite module in Python, you can refer to the official Python documentation."}, {"role": "assistant", "content": "Bun is a high-performance SQLite3 driver that can be imported from the built-in module. It provides a simple, synchronous, and fast API. Some features include transactions, parameters (named and positional), prepared statements, and datatype conversions. The performance of the Bun module is significantly faster than other SQLite drivers for JavaScript. It is roughly 3-6x faster than better-sqlite3 and 8-9x faster than deno.land/x/sqlite for read queries. \n\nTo use the Bun module, you can create a new database instance by providing a filename or use an in-memory database. There are options to open the database in read-only mode or create it if the file doesn't exist. You can also close the database manually, although it is automatically closed when garbage collected.\n\nTo execute SQL queries, you can use the query method on the database instance. It returns a statement instance, which can be prepared with a query but not executed immediately. There are different methods on the statement instance to execute the query and retrieve results in various formats, such as an array of objects or an array of arrays. The statement can also be finalized to free up associated resources.\n\nQueries can contain parameters, which can be numerical or named. Values can be bound to these parameters when executing the query. \n\nTransactions are supported in Bun and allow for executing multiple queries atomically. Transactions can be created using the transaction method on the database instance. They automatically begin when called and commit when the wrapped function returns. If an exception is thrown, the transaction is rolled back. \n\nBun also supports loading SQLite extensions by calling the loadExtension method on the database instance. \n\nReference:\n- `Database` class with a constructor and `query` method\n- `Statement` class with various methods for executing queries and manipulating the statement\n- `SQLQueryBindings` type for specifying query parameters\n\nOverall, Bun provides a powerful and efficient SQLite3 driver with a simple and intuitive API for JavaScript applications."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and knowledgeable in buns."}, {"role": "user", "content": "The Docs/api/streams provides instructions on how to work with streams in programming. It explains what streams are and how to use them effectively. The content covers topics such as reading from and writing to streams, handling errors, and working with different types of streams, such as readable and writable streams. The instructions also provide code examples to illustrate how to implement stream functionalities in different programming languages, such as JavaScript, Python, and Java. To summarize, the Docs/api/streams provides comprehensive guidance on working with streams, covering various aspects and programming languages."}, {"role": "assistant", "content": "Streams are a key abstraction for handling binary data without loading it all into memory at once. They are commonly used for file operations, network requests, and processing large amounts of data.\n\nBun implements the Web APIs for streams and provides optimized versions of ReadableStream and WritableStream. The ReadableStream can be created with a start method that enqueues chunks of data to be read, and the data can be consumed using a for-await-of loop.\n\nBun also offers a direct mode for ReadableStream that avoids unnecessary data copying and queue management. In this mode, chunks of data are written directly to the stream without enqueuing them. The WritableStream API is updated to support this mode, using the write method instead of enqueue.\n\nBun provides the ArrayBufferSink class, which is a fast incremental writer for constructing an ArrayBuffer of unknown size. The write method of ArrayBufferSink supports strings, typed arrays, ArrayBuffer, and SharedArrayBuffer. Once the end method is called, no more data can be written to the sink. However, if continuous writing and periodic flushing of the data is required, the stream option can be passed to the constructor.\n\nThe flush method returns the buffered data as an ArrayBuffer or Uint8Array and clears the internal buffer. The size of the internal buffer can be manually set by passing a value for the highWaterMark option in the constructor.\n\nFor more details, refer to the documentation in the Node.js docs."}]}
{"messages": [{"role": "system", "content": "You excel in TypeScript and are skilled in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/tcp instructions provide an overview of how to work with TCP sockets in a programming language. It covers the basics of TCP communication, such as creating a TCP server and a TCP client, establishing a connection, sending and receiving data, and handling errors. The instructions also include sample code snippets and explanations of the different methods and functions available for TCP socket manipulation. The documentation is especially useful for beginners looking to understand the fundamentals of TCP networking and develop networked applications."}, {"role": "assistant", "content": "Bun's native TCP API is designed for implementing performance-sensitive systems like database clients and game servers that need to communicate over TCP. It provides a low-level API that is optimized for speed.\n\nTo start a TCP server, use the `Bun.listen()` function and pass in the desired configuration, including the hostname and port. You can also define socket handlers for events like data receiving, socket opening and closing, draining, and error handling. This approach reduces garbage collector pressure and memory usage compared to assigning listeners to each socket individually.\n\nYou can attach contextual data to a socket using the socket handler. This can be useful for storing session information or other data related to the socket.\n\nTo enable TLS encryption, pass a TLS configuration object containing the key and certificate fields. Note that earlier versions of Bun supported passing file paths as these fields, but this has been deprecated. Instead, pass the contents of the key and certificate as strings, Buffers, or BunFiles.\n\nTo create a TCP connection to a server, use the `Bun.connect()` function and specify the server's hostname and port. You can define the same set of socket handlers as for the server, along with client-specific handlers for connection errors, server-initiated connection closure, and timeouts. TLS can also be enabled for the client connection.\n\nBoth TCP servers and sockets in Bun can be hot reloaded with new handlers. This allows for dynamic updates to the server and client behavior without restarting the program.\n\nBuffering is an important consideration for performance-sensitive code. Currently, TCP sockets in Bun do not provide built-in buffering. It's recommended to carefully manage buffering, as sending data in smaller chunks can significantly impact performance. The use of Bun's `ArrayBufferSink` with the `stream` option can help simplify buffering.\n\nSupport for corking, a feature that allows for more efficient data transmission, is planned for a future release of Bun. In the meantime, backpressure must be managed manually using the `drain` handler."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The following content contains instructions for using the Docs API test feature:\n\n1. To begin, you need to authenticate your request by including your API key as a parameter in the URL. The API key can be retrieved from the Google Cloud Console.\nExample: `POST /v1/documents:analyzeSentiment?key=YOUR_API_KEY`\n\n2. The request body should contain the content which you want to analyze. The content can be provided in a plain text format or in HTML format.\nExample: `{\n  \"document\": {\n    \"content\": \"I love this product!\",\n    \"type\": \"PLAIN_TEXT\"\n  }\n}`\n\n3. By default, the API will analyze the sentiment of the content. You can specify additional features to analyze by adding them as options in the request body.\nExample: `{\n  \"document\": {\n    \"content\": \"I love this product!\",\n    \"type\": \"PLAIN_TEXT\"\n  },\n  \"features\": {\n    \"extractSyntax\": true\n  }\n}`\n\n4. The response will include the analyzed sentiment or other requested features. You can access the different elements of the analysis by parsing the JSON response.\nExample: `{\n  \"documentSentiment\": {\n    \"magnitude\": 0.9,\n    \"score\": 0.6\n  }\n}`\n\nOverall, these instructions guide you through the process of authenticating your request, providing the content to be analyzed, specifying additional features, and accessing the analysis results in the response."}, {"role": "assistant", "content": "The documentation provides important information. It is recommended to refer to the documentation for more details."}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/transpiler section provides instructions for using the transpiler in the API library. The transpiler is responsible for converting code written in one language to another language. The instructions explain how to initialize the transpiler, specify the source language, specify the target language, and run the transpiler. Various code examples are given, showcasing different language conversions like JavaScript to Python, C# to Java, and Ruby to TypeScript. The instructions also mention the available customizations and provide information on error handling. It is recommended to read the full documentation for a detailed understanding of using the transpiler in the API library."}, {"role": "assistant", "content": "Bun's internal transpiler can be accessed through the `Transpiler` class. To create an instance of the transpiler, you can use the following code:\n\n```typescript\nconst transpiler = new Bun.Transpiler({\n  loader: \"tsx\", // \"js | \"jsx\" | \"ts\" | \"tsx\"\n});\n```\n\nYou can transpile code synchronously using the `transformSync` method. This method takes the code as input and returns a string of vanilla JavaScript code. Here's an example:\n\n```javascript\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\nconst code = `\nimport * as whatever from \"./whatever.ts\";\nexport function Home(props: {title: string}){\n  return <p>{props.title}</p>;\n}`;\nconst result = transpiler.transformSync(code);\n```\n\nYou can also transpile code asynchronously using the `transform` method. This method is an async version of `transformSync` and returns a promise that resolves to the transpiled code. Here's an example:\n\n```javascript\nconst transpiler = new Bun.Transpiler({ loader: \"jsx\" });\nconst result = await transpiler.transform(\"<div>hi!</div>\");\nconsole.log(result);\n```\n\nTo override the default loader specified in the constructor, you can pass a second argument to the `transform` method. For example:\n\n```typescript\nawait transpiler.transform(\"<div>hi!</div>\", \"tsx\");\n```\n\nThe `scan` method can be used to scan source code and return a list of imports and exports, along with additional metadata about each one. Type-only imports and exports are ignored. Here's an example:\n\n```typescript\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\nconst code = `\nimport React from 'react';\nimport type {ReactNode} from 'react';\nconst val = require('./cjs.js');\nimport('./loader');\nexport const name = \"hello\";\n`;\nconst result = transpiler.scan(code);\n```\n\nThe `scanImports` method provides a faster alternative to `scan` for getting a list of imports. It returns an array of import objects, each containing the imported path and the import kind. Here's an example:\n\n```typescript\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\nconst code = `\nimport React from 'react';\ntype {ReactNode} from 'react';\nconst val = require('./cjs.js');\nimport('./loader');\nexport const name = \"hello\";\n`;\nconst result = transpiler.scanImports(code);\n```\n\nThe `TranspilerOptions` interface defines the available options for the `Transpiler` class. Some of the options include:\n\n- `loader`: Specifies the default loader for the transpiler.\n- `target`: Specifies the default platform to target.\n- `tsconfig`: Specifies a custom tsconfig.json file.\n- `macro`: Replaces imports with macros.\n- `exports`: Specifies a set of exports to eliminate or rename.\n- `trimUnusedImports`: Removes unused imports from the transpiled file.\n- `minifyWhitespace`: Enables whitespace minification.\n- `inline`: Enables inlining of constant values.\n\nOverall, the `Transpiler` class in Bun provides a powerful and flexible way to transpile code and work with imports and exports."}]}
{"messages": [{"role": "system", "content": "You are a TypeScript expert."}, {"role": "user", "content": "The Docs/api/utils instructions provide useful functions for handling common tasks in programming. These functions include string manipulation, data formatting, and error handling.\n\nThe string manipulation functions enable developers to concatenate strings, convert strings to uppercase or lowercase, and split strings into substrings. These functions are useful for tasks such as generating dynamic messages or manipulating user input.\n\nThe data formatting functions allow programmers to format data in various ways. The number formatting functions can round decimal numbers, add commas as thousands separators, or format numbers as percentages. The date formatting functions can format dates in different date formats or extract specific components of a date, such as the year or month.\n\nThe error handling functions assist developers in managing and responding to errors during program execution. These functions include logging error messages, throwing custom exceptions, and handling specific types of errors. By using these functions, programmers can ensure that their code handles errors gracefully and provides meaningful feedback to users.\n\nIn summary, the Docs/api/utils instructions provide a collection of functions that are helpful for common programming tasks. These functions cover string manipulation, data formatting, and error handling, enabling developers to write efficient and robust code."}, {"role": "assistant", "content": "`ts\nconst resolvedPath = Bun.resolvePath(\"./myModule\", \"/path/to/root\");\nconsole.log(resolvedPath); // \"/path/to/root/myModule\"\n`\nIf the second argument is not provided, Bun will use the current working directory as the \"root\".\nAn error is thrown if no match is found. The `Bun.resolveSync` function can be used to resolve file paths. When resolving relative to the current working directory, either pass `null` or `undefined` as the root parameter. To resolve relative to the directory containing the current file, pass `import.meta.dir` as the root.\n\nTo save a JavaScript value into an ArrayBuffer and then convert it back, use the `serialize` and `deserialize` functions from the `bun:jsc` module. These functions internally use the HTML Structured Clone Algorithm to convert the value into an ArrayBuffer. Here is an example of usage:\n\n```js\nimport { serialize, deserialize } from \"bun:jsc\";\nconst buf = serialize({ foo: \"bar\" });\nconst obj = deserialize(buf);\nconsole.log(obj); // => { foo: \"bar\" }\n```"}]}
{"messages": [{"role": "system", "content": "You are experienced in TypeScript development and have a strong understanding of bun-making."}, {"role": "user", "content": "The websockets API in the Docs provides a way to establish a connection between a client and a server, allowing for real-time communication. To establish a websocket connection, the client sends a request to the server using the websocket protocol. The server then sends a response containing the websocket protocol in the header. Once the connection is established, the client and server can exchange messages in both directions.\n\nTo use websockets in your application, you need to create a new WebSocket object in JavaScript. The constructor takes as an argument the URL of the websocket server. You can then use methods on the WebSocket object to send and receive messages. The onopen event is triggered when the connection is successfully established, while the onmessage event is triggered when a message is received.\n\nTo send a message, you can use the send method on the WebSocket object, passing in the message as an argument. The message can be a string, ArrayBuffer, or Blob object. To receive a message, you can listen for the onmessage event and access the message data in the event object.\n\nIt's important to handle errors and close the websocket connection properly. The onclose event is triggered when the connection is closed, and you can check the close code and reason for more information. You can also close the connection manually using the close method on the WebSocket object.\n\nIn addition to the basic functionality, the websockets API supports advanced features such as subprotocols and extensions. Subprotocols allow for the negotiation of a specific application-level protocol on top of the websocket protocol. Extensions enable the use of additional functionality, such as compression or encryption, in the messages exchanged between the client and server.\n\nOverall, the websockets API provides an efficient and convenient way to enable real-time communication between a client and server."}, {"role": "assistant", "content": "Bun is a server-side WebSocket framework that supports on-the-fly compression, TLS, and a Bun-native publish-subscribe API. It offers 7x more throughput compared to Node.js in a simple chatroom scenario. Internally, Bun's WebSocket implementation is built on uWebSockets. The WebSocket server can be started with a simple code snippet provided in the documentation. Handlers for different WebSocket events like message, open, close, and drain can be declared as part of the server configuration. Bun's WebSocket implementation uses a method-based API instead of an event-based API, which allows for better memory usage and performance. It also supports sending messages, setting headers, attaching contextual data to WebSockets, and connecting to external socket servers. Bun's WebSocket implementation also provides features"}]}
{"messages": [{"role": "system", "content": "You are skilled in TypeScript and have expertise in Bun which is a TypeScript and JavaScript runtime, package manager, bundler, among other capabilities."}, {"role": "user", "content": "The Docs/api/workers section provides instructions on how to utilize workers in an application. Workers are JavaScript scripts that run in the background independently of the main application thread. They can be used to perform tasks such as making network requests, handling complex calculations, and processing large amounts of data.\n\nTo create a new worker, you can use the `new Worker()` constructor and pass in the URL of the worker script. You can also specify options such as `type`, `credentials`, and `name`. Once the worker is created, you can send messages to it using the `postMessage()` method, and the worker can respond by listening for the `message` event.\n\nTo handle messages sent by the worker, you can add an event listener with the `message` event type to the worker object. The received message can then be processed and the result can be sent back using the `postMessage()` method.\n\nTo terminate a worker, you can call the `terminate()` method on the worker object. This will stop the worker from executing any further code and release any resources associated with it.\n\nOverall, workers are a useful tool for offloading intensive tasks from the main application thread, improving performance and responsiveness. They can be easily integrated into an application by following the provided instructions."}, {"role": "assistant", "content": "Bun v0.7.0 added support for creating and communicating with JavaScript instances running on separate threads while sharing I/O resources with the main thread. It implements a minimal version of the Web Workers API with extensions for server-side use cases. Bun supports multiple languages and modules out of the box. \n\nTo create a new worker thread, use the `Worker` constructor. Messages can be sent and received using the `postMessage` and `onmessage` methods respectively. Workers can be terminated using the `terminate` method. The `close` event is emitted when a worker has been terminated. \n\nTo manage the lifetime of a worker, `unref` can be called to decouple the worker's lifetime from the main process, while `ref` can be called to keep the process alive until the worker terminates. \n\nAdditionally, Bun's worker implementation supports a `smol` mode that reduces memory usage at the cost of performance. This can be enabled by passing `{ smol: true }` to the `Worker` constructor."}]}
