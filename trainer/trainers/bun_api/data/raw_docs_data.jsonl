{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/binary Data instructions from the following content:"}, {"role": "assistant", "content": "This page is intended as an introduction to working with binary data in JavaScript. Bun implements a number of data types and utilities for working with binary data, most of which are Web-standard. Any Bun-specific APIs will be noted as such.\n\nBelow is a quick \"cheat sheet\" that doubles as a table of contents. Click an item in the left column to jump to that section.\n\n{% table %}\n\n---\n\n- [`TypedArray`](#typedarray)\n- A family of classes that provide an `Array`-like interface for interacting with binary data. Includes `Uint8Array`, `Uint16Array`, `Int8Array`, and more.\n\n---\n\n- [`Buffer`](#buffer)\n- A subclass of `Uint8Array` that implements a wide range of convenience methods. Unlike the other elements in this table, this is a Node.js API (which Bun implements). It can't be used in the browser.\n\n---\n\n- [`DataView`](#dataview)\n- A class that provides a `get/set` API for writing some number of bytes to an `ArrayBuffer` at a particular byte offset. Often used reading or writing binary protocols.\n\n---\n\n- [`Blob`](#blob)\n- A readonly blob of binary data usually representing a file. Has a MIME `type`, a `size`, and methods for converting to `ArrayBuffer`, `ReadableStream`, and string.\n\n---\n\n<!-- - [`File`](#file)\n- _Browser only_. A subclass of `Blob` that represents a file. Has a `name` and `lastModified` timestamp. There is experimental support in Node.js v20; Bun does not support `File` yet; most of its functionality is provided by `BunFile`.\n\n--- -->\n\n- [`BunFile`](#bunfile)\n- _Bun only_. A subclass of `Blob` that represents a lazily-loaded file on disk. Created with `Bun.file(path)`.\n\n{% /table %}\n\n## `ArrayBuffer` and views\n\nUntil 2009, there was no language-native way to store and manipulate binary data in JavaScript. ECMAScript v5 introduced a range of new mechanisms for this. The most fundamental building block is `ArrayBuffer`, a simple data structure that represents a sequence of bytes in memory.\n\n```ts\n// this buffer can store 8 bytes\nconst buf = new ArrayBuffer(8);\n```\n\nDespite the name, it isn't an array and supports none of the array methods and operators one might expect. In fact, there is no way to directly read or write values from an `ArrayBuffer`. There's very little you can do with one except check its size and create \"slices\" from it.\n\n```ts\nconst buf = new ArrayBuffer(8);\n\nbuf.byteLength; // => 8\n\nconst slice = buf.slice(0, 4); // returns new ArrayBuffer\nslice.byteLength; // => 4\n```\n\nTo do anything interesting we need a construct known as a \"view\". A view is a class that _wraps_ an `ArrayBuffer` instance and lets you read and manipulate the underlying data. There are two types of views: _typed arrays_ and `DataView`.\n\n### `DataView`\n\nThe `DataView` class is a lower-level interface for reading and manipulating the data in an `ArrayBuffer`.\n\nBelow we create a new `DataView` and set the first byte to 5.\n\n```ts\nconst buf = new ArrayBuffer(4);\n// [0x0, 0x0, 0x0, 0x0]\n\nconst dv = new DataView(buf);\ndv.setUint8(0, 3); // write value 3 at byte offset 0\ndv.getUint8(0); // => 3\n// [0x11, 0x0, 0x0, 0x0]\n```\n\nNow lets write a `Uint16` at byte offset `1`. This requires two bytes. We're using the value `513`, which is `2 * 256 + 1`; in bytes, that's `00000010 00000001`.\n\n```ts\ndv.setUint16(1, 513);\n// [0x11, 0x10, 0x1, 0x0]\n\nconsole.log(dv.getUint16(1)); // => 513\n```\n\nWe've now assigned a value to the first three bytes in our underlying `ArrayBuffer`. Even though the second and third bytes were created using `setUint16()`, we can still read each of its component bytes using `getUint8()`.\n\n```ts\nconsole.log(dv.getUint8(1)); // => 2\nconsole.log(dv.getUint8(2)); // => 1\n```\n\nAttempting to write a value that requires more space than is available in the underlying `ArrayBuffer` will cuase an error. Below we attempt to write a `Float64` (which requires 8 bytes) at byte offset `0`, but there are only four total bytes in the buffer.\n\n```ts\ndv.setFloat64(0, 3.1415);\n// ^ RangeError: Out of bounds access\n```\n\nThe following methods are available on `DataView`:\n\n{% table %}\n\n- Getters\n- Setters\n\n---\n\n- [`getBigInt64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getBigInt64)\n- [`setBigInt64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setBigInt64)\n\n---\n\n- [`getBigUint64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getBigUint64)\n- [`setBigUint64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setBigUint64)\n\n---\n\n- [`getFloat32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat32)\n- [`setFloat32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat32)\n\n---\n\n- [`getFloat64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat64)\n- [`setFloat64()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat64)\n\n---\n\n- [`getInt16()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt16)\n- [`setInt16()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt16)\n\n---\n\n- [`getInt32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt32)\n- [`setInt32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt32)\n\n---\n\n- [`getInt8()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt8)\n- [`setInt8()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt8)\n\n---\n\n- [`getUint16()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16)\n- [`setUint16()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16)\n\n---\n\n- [`getUint32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32)\n- [`setUint32()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32)\n\n---\n\n- [`getUint8()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint8)\n- [`setUint8()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint8)\n\n{% /table %}\n\n### `TypedArray`\n\nTyped arrays are a family of classes that provide an `Array`-like interface for interacting with data in an `ArrayBuffer`. Whereas a `DataView` lets you write numbers of varying size at a particular offset, a `TypedArray` interprets the underlying bytes as an array of numbers, each of a fixed size.\n\n{% callout %}\n**Note** \u2014 It's common to refer to this family of classes collectively by their shared superclass `TypedArray`. This class as _internal_ to JavaScript; you can't directly create instances of it, and `TypedArray` is not defined in the global scope. Think of it as an `interface` or an abstract class.\n{% /callout %}\n\n```ts\nconst buffer = new ArrayBuffer(3);\nconst arr = new Uint8Array(buffer);\n\n// contents are initialized to zero\nconsole.log(arr); // Uint8Array(3) [0, 0, 0]\n\n// assign values like an array\narr[0] = 0;\narr[1] = 10;\narr[2] = 255;\narr[3] = 255; // no-op, out of bounds\n```\n\nWhile an `ArrayBuffer` is a generic sequence of bytes, these typed array classes interpret the bytes as an array of numbers of a given byte size.\nThe top row contains the raw bytes, and the later rows contain how these bytes will be interpreted when _viewed_ using different typed array classes.\n\nThe following classes are typed arrays, along with a description of how they interpret the bytes in an `ArrayBuffer`:\n\n{% table %}\n\n- Class\n- Description\n\n---\n\n- [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)\n- Every one (1) byte is interpreted as an unsigned 8-bit integer. Range 0 to 255.\n\n---\n\n- [`Uint16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array)\n- Every two (2) bytes are interpreted as an unsigned 16-bit integer. Range 0 to 65535.\n\n---\n\n- [`Uint32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array)\n- Every four (4) bytes are interpreted as an unsigned 32-bit integer. Range 0 to 4294967295.\n\n---\n\n- [`Int8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array)\n- Every one (1) byte is interpreted as a signed 8-bit integer. Range -128 to 127.\n\n---\n\n- [`Int16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array)\n- Every two (2) bytes are interpreted as a signed 16-bit integer. Range -32768 to 32767.\n\n---\n\n- [`Int32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array)\n- Every four (4) bytes are interpreted as a signed 32-bit integer. Range -2147483648 to 2147483647.\n\n---\n\n- [`Float32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)\n- Every four (4) bytes are interpreted as a 32-bit floating point number. Range -3.4e38 to 3.4e38.\n\n---\n\n- [`Float64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array)\n- Every eight (8) bytes are interpreted as a 64-bit floating point number. Range -1.7e308 to 1.7e308.\n\n---\n\n- [`BigInt64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array)\n- Every eight (8) bytes are interpreted as an unsigned `BigInt`. Range -9223372036854775808 to 9223372036854775807 (though `BigInt` is capable of representing larger numbers).\n\n---\n\n- [`BigUint64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array)\n- Every eight (8) bytes are interpreted as an unsigned `BigInt`. Range 0 to 18446744073709551615 (though `BigInt` is capable of representing larger numbers).\n\n---\n\n- [`Uint8ClampedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)\n- Same as `Uint8Array`, but automatically \"clamps\" to the range 0-255 when assigning a value to an element.\n\n{% /table %}\n\nThe table below demonstrates how the bytes in an `ArrayBuffer` are interpreted when viewed using different typed array classes.\n\n{% table %}\n\n---\n\n- `ArrayBuffer`\n- `00000000`\n- `00000001`\n- `00000010`\n- `00000011`\n- `00000100`\n- `00000101`\n- `00000110`\n- `00000111`\n\n---\n\n- `Uint8Array`\n- 0\n- 1\n- 2\n- 3\n- 4\n- 5\n- 6\n- 7\n\n---\n\n- `Uint16Array`\n- 256 (`1 * 256 + 0`) {% colspan=2 %}\n- 770 (`3 * 256 + 2`) {% colspan=2 %}\n- 1284 (`5 * 256 + 4`) {% colspan=2 %}\n- 1798 (`7 * 256 + 6`) {% colspan=2 %}\n\n---\n\n- `Uint32Array`\n- 50462976 {% colspan=4 %}\n- 117835012 {% colspan=4 %}\n\n---\n\n- `BigUint64Array`\n- 506097522914230528n {% colspan=8 %}\n\n{% /table %}\n\nTo create a typed array from a pre-defined `ArrayBuffer`:\n\n```ts\n// create typed array from ArrayBuffer\nconst buf = new ArrayBuffer(10);\nconst arr = new Uint8Array(buf);\n\narr[0] = 30;\narr[1] = 60;\n\n// all elements are initialized to zero\nconsole.log(arr); // => Uint8Array(10) [ 30, 60, 0, 0, 0, 0, 0, 0, 0, 0 ];\n```\n\nIf we tried to instantiate a `Uint32Array` from this same `ArrayBuffer`, we'd get an error.\n\n```ts\nconst buf = new ArrayBuffer(10);\nconst arr = new Uint32Array(buf);\n//          ^  RangeError: ArrayBuffer length minus the byteOffset\n//             is not a multiple of the element size\n```\n\nA `Uint32` value requires four bytes (16 bits). Because the `ArrayBuffer` is 10 bytes long, there's no way to cleanly divide its contents into 4-byte chunks.\n\nTo fix this, we can create a typed array over a particular \"slice\" of an `ArrayBuffer`. The `Uint16Array` below only \"views\" the _first_ 8 bytes of the underlying `ArrayBuffer`. To achieve these, we specify a `byteOffset` of `0` and a `length` of `2`, which indicates the number of `Uint32` numbers we want our array to hold.\n\n```ts\n// create typed array from ArrayBuffer slice\nconst buf = new ArrayBuffer(10);\nconst arr = new Uint32Array(buf, 0, 2);\n\n/*\n  buf    _ _ _ _ _ _ _ _ _ _    10 bytes\n  arr   [_______,_______]       2 4-byte elements\n*/\n\narr.byteOffset; // 0\narr.length; // 2\n```\n\nYou don't need to explicitly create an `ArrayBuffer` instance; you can instead directly specify a length in the typed array constructor:\n\n```ts\nconst arr2 = new Uint8Array(5);\n\n// all elements are initialized to zero\n// => Uint8Array(5) [0, 0, 0, 0, 0]\n```\n\nTyped arrays can also be instantiated directly from an array of numbers, or another typed array:\n\n```ts\n// from an array of numbers\nconst arr1 = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);\narr1[0]; // => 0;\narr1[7]; // => 7;\n\n// from another typed array\nconst arr2 = new Uint8Array(arr);\n```\n\nBroadly speaking, typed arrays provide the same methods as regular arrays, with a few exceptions. For example, `push` and `pop` are not available on typed arrays, because they would require resizing the underlying `ArrayBuffer`.\n\n```ts\nconst arr = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);\n\n// supports common array methods\narr.filter(n => n > 128); // Uint8Array(1) [255]\narr.map(n => n * 2); // Uint8Array(8) [0, 2, 4, 6, 8, 10, 12, 14]\narr.reduce((acc, n) => acc + n, 0); // 28\narr.forEach(n => console.log(n)); // 0 1 2 3 4 5 6 7\narr.every(n => n < 10); // true\narr.find(n => n > 5); // 6\narr.includes(5); // true\narr.indexOf(5); // 5\n```\n\nRefer to the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) for more information on the properties and methods of typed arrays.\n\n### `Uint8Array`\n\nIt's worth specifically highlighting `Uint8Array`, as it represents a classic \"byte array\"\u2014a sequence of 8-bit unsigned integers between 0 and 255. This is the most common typed array you'll encounter in JavaScript.\n\nIt is the return value of [`TextEncoder#encode`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder), and the input type of [`TextDecoder#decode`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder), two utility classes designed to translate strings and various binary encodings, most notably `\"utf-8\"`.\n\n```ts\nconst encoder = new TextEncoder();\nconst bytes = encoder.encode(\"hello world\");\n// => Uint8Array(11) [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ]\n\nconst decoder = new TextDecoder();\nconst text = decoder.decode(bytes);\n// => hello world\n```\n\n### `Buffer`\n\nBun implements `Buffer`, a Node.js API for working with binary data that pre-dates the introduction of typed arrays in the JavaScript spec. It has since been re-implemented as a subclass of `Uint8Array`. It provides a wide range of methods, including several Array-like and `DataView`-like methods.\n\n```ts\nconst buf = Buffer.from(\"hello world\");\n// => Buffer(16) [ 116, 104, 105, 115, 32, 105, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103 ]\n\nbuf.length; // => 11\nbuf[0]; // => 104, ascii for 'h'\nbuf.writeUInt8(72, 0); // => ascii for 'H'\n\nconsole.log(buf.toString());\n// => Hello world\n```\n\nFor complete documentation, refer to the [Node.js documentation](https://nodejs.org/api/buffer.html).\n\n## `Blob`\n\n`Blob` is a Web API commonly used for representing files. `Blob` was initially implemented in browsers (unlike `ArrayBuffer` which is part of JavaScript itself), but it is now supported in Node and Bun.\n\nIt isn't common to directly create `Blob` instances. More often, you'll recieve instances of `Blob` from an external source (like an `<input type=\"file\">` element in the browser) or library. That said, it is possible to create a `Blob` from one or more string or binary \"blob parts\".\n\n```ts\nconst blob = new Blob([\"<html>Hello</html>\"], {\n  type: \"text/html\",\n});\n\nblob.type; // => text/html\nblob.size; // => 19\n```\n\nThese parts can be `string`, `ArrayBuffer`, `TypedArray`, `DataView`, or other `Blob` instances. The blob parts are concatenated together in the order they are provided.\n\n```ts\nconst blob = new Blob([\n  \"<html>\",\n  new Blob([\"<body>\"]),\n  new Uint8Array([104, 101, 108, 108, 111]), // \"hello\" in binary\n  \"</body></html>\",\n]);\n```\n\nThe contents of a `Blob` can be asynchronously read in various formats.\n\n```ts\nawait blob.text(); // => <html><body>hello</body></html>\nawait blob.arrayBuffer(); // => ArrayBuffer (copies contents)\nawait blob.stream(); // => ReadableStream\n```\n\n### `BunFile`\n\n`BunFile` is a subclass of `Blob` used to represent a lazily-loaded file on disk. Like `File`, it adds a `name` and `lastModified` property. Unlike `File`, it does not require the file to be loaded into memory.\n\n```ts\nconst file = Bun.file(\"index.txt\");\n// => BunFile\n```\n\n### `File`\n\n{% callout %}\nBrowser only. Experimental support in Node.js 20.\n{% /callout %}\n\n[`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) is a subclass of `Blob` that adds a `name` and `lastModified` property. It's commonly used in the browser to represent files uploaded via a `<input type=\"file\">` element. Node.js and Bun implement `File`.\n\n```ts\n// on browser!\n// <input type=\"file\" id=\"file\" />\n\nconst files = document.getElementById(\"file\").files;\n// => File[]\n```\n\n```ts\nconst file = new File([\"<html>Hello</html>\"], \"index.html\", {\n  type: \"text/html\",\n});\n```\n\nRefer to the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/API/Blob) for complete docs information.\n\n## Streams\n\nStreams are an important abstraction for working with binary data without loading it all into memory at once. They are commonly used for reading and writing files, sending and receiving network requests, and processing large amounts of data.\n\nBun implements the Web APIs [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) and [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).\n\n{% callout %}\nBun also implements the `node:stream` module, including [`Readable`](https://nodejs.org/api/stream.html#stream_readable_streams), [`Writable`](https://nodejs.org/api/stream.html#stream_writable_streams), and [`Duplex`](https://nodejs.org/api/stream.html#stream_duplex_and_transform_streams). For complete documentation, refer to the Node.js docs.\n{% /callout %}\n\nTo create a simple readable stream:\n\n```ts\nconst stream = new ReadableStream({\n  start(controller) {\n    controller.enqueue(\"hello\");\n    controller.enqueue(\"world\");\n    controller.close();\n  },\n});\n```\n\nThe contents of this stream can be read chunk-by-chunk with `for await` syntax.\n\n```ts\nfor await (const chunk of stream) {\n  console.log(chunk);\n  // => \"hello\"\n  // => \"world\"\n}\n```\n\nFor a more complete discusson of streams in Bun, see [API > Streams](/docs/api/streams).\n\n## Conversion\n\nConverting from one binary format to another is a common task. This section is intended as a reference.\n\n### From `ArrayBuffer`\n\nSince `ArrayBuffer` stores the data that underlies other binary structures like `TypedArray`, the snippets below are not _converting_ from `ArrayBuffer` to another format. Instead, they are _creating_ a new instance using the data stored underlying data.\n\n#### To `TypedArray`\n\n```ts\nnew Uint8Array(buf);\n```\n\n#### To `DataView`\n\n```ts\nnew DataView(buf);\n```\n\n#### To `Buffer`\n\n```ts\n// create Buffer over entire ArrayBuffer\nBuffer.from(buf);\n\n// create Buffer over a slice of the ArrayBuffer\nBuffer.from(buf, 0, 10);\n```\n\n#### To `string`\n\n```ts\nnew TextDecoder().decode(buf);\n```\n\n#### To `number[]`\n\n```ts\nArray.from(new Uint8Array(buf));\n```\n\n#### To `Blob`\n\n```ts\nnew Blob([buf], { type: \"text/plain\" });\n```\n\n<!-- #### To `File`\n\n```ts\nnew File([buf], \"filename.txt\", { type: \"text/plain\", lastModified: Date.now() });\n``` -->\n\n#### To `ReadableStream`\n\nThe following snippet creates a `ReadableStream` and enqueues the entire `ArrayBuffer` as a single chunk.\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    controller.enqueue(buf);\n    controller.close();\n  },\n});\n```\n\n{% details summary=\"With chunking\" %}\nTo stream the `ArrayBuffer` in chunks, use a `Uint8Array` view and enqueue each chunk.\n\n```ts\nconst view = new Uint8Array(buf);\nconst chunkSize = 1024;\n\nnew ReadableStream({\n  start(controller) {\n    for (let i = 0; i < view.length; i += chunkSize) {\n      controller.enqueue(view.slice(i, i + chunkSize));\n    }\n    controller.close();\n  },\n});\n```\n\n{% /details %}\n\n### From `TypedArray`\n\n#### To `ArrayBuffer`\n\nThis retrieves the underlying `ArrayBuffer`. Note that a `TypedArray` can be a view of a _slice_ of the underlying buffer, so the sizes may differ.\n\n```ts\narr.buffer;\n```\n\n#### To `DataView`\n\nTo creates a `DataView` over the same byte range as the TypedArray.\n\n```ts\nnew DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n```\n\n#### To `Buffer`\n\n```ts\nBuffer.from(arr);\n```\n\n#### To `string`\n\n```ts\nnew TextDecoder().decode(arr);\n```\n\n#### To `number[]`\n\n```ts\nArray.from(arr);\n```\n\n#### To `Blob`\n\n```ts\nnew Blob([arr.buffer], { type: \"text/plain\" });\n```\n\n<!-- #### To `File`\n\n```ts\nnew File([arr.buffer], \"filename.txt\", { type: \"text/plain\", lastModified: Date.now() });\n``` -->\n\n#### To `ReadableStream`\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    controller.enqueue(arr);\n    controller.close();\n  },\n});\n```\n\n{% details summary=\"With chunking\" %}\nTo stream the `ArrayBuffer` in chunks, split the `TypedArray` into chunks and enqueue each one individually.\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    for (let i = 0; i < arr.length; i += chunkSize) {\n      controller.enqueue(arr.slice(i, i + chunkSize));\n    }\n    controller.close();\n  },\n});\n```\n\n{% /details %}\n\n### From `DataView`\n\n#### To `ArrayBuffer`\n\n```ts\nview.buffer;\n```\n\n#### To `TypedArray`\n\nOnly works if the `byteLength` of the `DataView` is a multiple of the `BYTES_PER_ELEMENT` of the `TypedArray` subclass.\n\n```ts\nnew Uint8Array(view.buffer, view.byteOffset, view.byteLength);\nnew Uint16Array(view.buffer, view.byteOffset, view.byteLength / 2);\nnew Uint32Array(view.buffer, view.byteOffset, view.byteLength / 4);\n// etc...\n```\n\n#### To `Buffer`\n\n```ts\nBuffer.from(view.buffer, view.byteOffset, view.byteLength);\n```\n\n#### To `string`\n\n```ts\nnew TextDecoder().decode(view);\n```\n\n#### To `number[]`\n\n```ts\nArray.from(view);\n```\n\n#### To `Blob`\n\n```ts\nnew Blob([view.buffer], { type: \"text/plain\" });\n```\n\n<!-- #### To `File`\n\n```ts\nnew File([view.buffer], \"filename.txt\", { type: \"text/plain\", lastModified: Date.now() });\n``` -->\n\n#### To `ReadableStream`\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    controller.enqueue(view.buffer);\n    controller.close();\n  },\n});\n```\n\n{% details summary=\"With chunking\" %}\nTo stream the `ArrayBuffer` in chunks, split the `DataView` into chunks and enqueue each one individually.\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    for (let i = 0; i < view.byteLength; i += chunkSize) {\n      controller.enqueue(view.buffer.slice(i, i + chunkSize));\n    }\n    controller.close();\n  },\n});\n```\n\n{% /details %}\n\n### From `Buffer`\n\n#### To `ArrayBuffer`\n\n```ts\nbuf.buffer;\n```\n\n#### To `TypedArray`\n\n```ts\nnew Uint8Array(buf);\n```\n\n#### To `DataView`\n\n```ts\nnew DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n```\n\n#### To `string`\n\n```ts\nbuf.toString();\n```\n\n#### To `number[]`\n\n```ts\nArray.from(buf);\n```\n\n#### To `Blob`\n\n```ts\nnew Blob([buf], { type: \"text/plain\" });\n```\n\n<!-- #### To `File`\n\n```ts\nnew File([buf], \"filename.txt\", { type: \"text/plain\", lastModified: Date.now() });\n``` -->\n\n#### To `ReadableStream`\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    controller.enqueue(buf);\n    controller.close();\n  },\n});\n```\n\n{% details summary=\"With chunking\" %}\nTo stream the `ArrayBuffer` in chunks, split the `Buffer` into chunks and enqueue each one individually.\n\n```ts\nnew ReadableStream({\n  start(controller) {\n    for (let i = 0; i < buf.length; i += chunkSize) {\n      controller.enqueue(buf.slice(i, i + chunkSize));\n    }\n    controller.close();\n  },\n});\n```\n\n{% /details %}\n\n### From `Blob`\n\n#### To `ArrayBuffer`\n\nThe `Blob` class provides a convenience method for this purpose.\n\n```ts\nawait blob.arrayBuffer();\n```\n\n#### To `TypedArray`\n\n```ts\nnew Uint8Array(await blob.arrayBuffer());\n```\n\n#### To `DataView`\n\n```ts\nnew DataView(await blob.arrayBuffer());\n```\n\n#### To `Buffer`\n\n```ts\nBuffer.from(await blob.arrayBuffer());\n```\n\n#### To `string`\n\n```ts\nawait blob.text();\n```\n\n#### To `number[]`\n\n```ts\nArray.from(new Uint8Array(await blob.arrayBuffer()));\n```\n\n#### To `ReadableStream`\n\n```ts\nblob.stream();\n```\n\n<!-- ### From `File` -->\n\n### From `ReadableStream`\n\nIt's common to use [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) as a convenient intermediate representation to make it easier to convert `ReadableStream` to other formats.\n\n```ts\nstream; // ReadableStream\n\nconst buffer = new Response(stream).arrayBuffer();\n```\n\nHowever this approach is verbose and adds overhead that slows down overall performance unnecessarily. Bun implements a set of optimized convenience functions for converting `ReadableStream` various binary formats.\n\n#### To `ArrayBuffer`\n\n```ts\n// with Response\nnew Response(stream).arrayBuffer();\n\n// with Bun function\nBun.readableStreamToArrayBuffer(stream);\n```\n\n#### To `TypedArray`\n\n```ts\n// with Response\nconst buf = await new Response(stream).arrayBuffer();\nnew Uint8Array(buf);\n\n// with Bun function\nnew Uint8Array(Bun.readableStreamToArrayBuffer(stream));\n```\n\n#### To `DataView`\n\n```ts\n// with Response\nconst buf = await new Response(stream).arrayBuffer();\nnew DataView(buf);\n\n// with Bun function\nnew DataView(Bun.readableStreamToArrayBuffer(stream));\n```\n\n#### To `Buffer`\n\n```ts\n// with Response\nconst buf = await new Response(stream).arrayBuffer();\nBuffer.from(buf);\n\n// with Bun function\nBuffer.from(Bun.readableStreamToArrayBuffer(stream));\n```\n\n#### To `string`\n\n```ts\n// with Response\nnew Response(stream).text();\n\n// with Bun function\nawait Bun.readableStreamToText(stream);\n```\n\n#### To `number[]`\n\n```ts\n// with Response\nconst buf = await new Response(stream).arrayBuffer();\nArray.from(new Uint8Array(buf));\n\n// with Bun function\nArray.from(new Uint8Array(Bun.readableStreamToArrayBuffer(stream)));\n```\n\nBun provides a utility for resolving a `ReadableStream` to an array of its chunks. Each chunk may be a string, typed array, or `ArrayBuffer`.\n\n```ts\n// with Bun function\nBun.readableStreamToArray(stream);\n```\n\n#### To `Blob`\n\n```ts\nnew Response(stream).blob();\n```\n\n<!-- #### To `File`\n\n```ts\nnew Response(stream)\n  .blob()\n  .then(blob => new File([blob], \"filename.txt\", { type: \"text/plain\", lastModified: Date.now() }));\n``` -->\n\n#### To `ReadableStream`\n\nTo split a `ReadableStream` into two streams that can be consumed independently:\n\n```ts\nconst [a, b] = stream.tee();\n```\n\n<!-- - Use Buffer\n- TextEncoder\n- `Bun.ArrayBufferSink`\n- ReadableStream\n- AsyncIterator\n- TypedArray vs ArrayBuffer vs DataView\n- Bun.indexOfLine\n- \u201cdirect\u201d readablestream\n  - readable stream has assumptions about\n  - its very generic\n  - all data is copies and queued\n  - direct : no queueing\n  - just a write function\n  - you can write strings\n  - more synchronous\n  - corking works better -->\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/console instructions from the following content:"}, {"role": "assistant", "content": "{% callout %}\n**Note** \u2014 Bun provides a browser- and Node.js-compatible [console](https://developer.mozilla.org/en-US/docs/Web/API/console) global. This page only documents Bun-native APIs.\n{% /callout %}\n\nIn Bun, the `console` object can be used as an `AsyncIterable` to sequentially read lines from `process.stdin`.\n\n```ts\nfor await (const line of console) {\n  console.log(line);\n}\n```\n\nThis is useful for implementing interactive programs, like the following addition calculator.\n\n```ts#adder.ts\nconsole.log(`Let's add some numbers!`);\nconsole.write(`Count: 0\\n> `);\n\nlet count = 0;\nfor await (const line of console) {\n  count += Number(line);\n  console.write(`Count: ${count}\\n> `);\n}\n```\n\nTo run the file:\n\n```bash\n$ bun adder.ts\nLet's add some numbers!\nCount: 0\n> 5\nCount: 5\n> 5\nCount: 10\n> 5\nCount: 15\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/dns instructions from the following content:"}, {"role": "assistant", "content": "Bun implements the `node:dns` module.\n\n```ts\nimport * as dns from \"node:dns\";\n\nconst addrs = await dns.promises.resolve4(\"bun.sh\", { ttl: true });\nconsole.log(addrs);\n// => [{ address: \"172.67.161.226\", family: 4, ttl: 0 }, ...]\n```\n\n<!--\n## `Bun.dns` - lookup a domain\n`Bun.dns` includes utilities to make DNS requests, similar to `node:dns`. As of Bun v0.5.0, the only implemented function is `dns.lookup`, though more will be implemented soon.\nYou can lookup the IP addresses of a hostname by using `dns.lookup`.\n```ts\nimport { dns } from \"bun\";\nconst [{ address }] = await dns.lookup(\"example.com\");\nconsole.log(address); // \"93.184.216.34\"\n```\nIf you need to limit IP addresses to either IPv4 or IPv6, you can specify the `family` as an option.\n```ts\nimport { dns } from \"bun\";\nconst [{ address }] = await dns.lookup(\"example.com\", { family: 6 });\nconsole.log(address); // \"2606:2800:220:1:248:1893:25c8:1946\"\n```\nBun supports three backends for DNS resolution:\n- `c-ares` - This is the default on Linux, and it uses the [c-ares](https://c-ares.org/) library to perform DNS resolution.\n- `system` - Uses the system's non-blocking DNS resolver, if available. Otherwise, falls back to `getaddrinfo`. This is the default on macOS, and the same as `getaddrinfo` on Linux.\n- `getaddrinfo` - Uses the POSIX standard `getaddrinfo` function, which may cause performance issues under concurrent load.\n\nYou can choose a particular backend by specifying `backend` as an option.\n```ts\nimport { dns } from \"bun\";\nconst [{ address, ttl }] = await dns.lookup(\"example.com\", {\n  backend: \"c-ares\"\n});\nconsole.log(address); // \"93.184.216.34\"\nconsole.log(ttl); // 21237\n```\nNote: the `ttl` property is only accurate when the `backend` is c-ares. Otherwise, `ttl` will be `0`.\nThis was added in Bun v0.5.0. -->\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/ffi instructions from the following content:"}, {"role": "assistant", "content": "Use the built-in `bun:ffi` module to efficiently call native libraries from JavaScript. It works with languages that support the C ABI (Zig, Rust, C/C++, C#, Nim, Kotlin, etc).\n\n## Usage (`bun:ffi`)\n\nTo print the version number of `sqlite3`:\n\n```ts\nimport { dlopen, FFIType, suffix } from \"bun:ffi\";\n\n// `suffix` is either \"dylib\", \"so\", or \"dll\" depending on the platform\n// you don't have to use \"suffix\", it's just there for convenience\nconst path = `libsqlite3.${suffix}`;\n\nconst {\n  symbols: {\n    sqlite3_libversion, // the function to call\n  },\n} = dlopen(\n  path, // a library name or file path\n  {\n    sqlite3_libversion: {\n      // no arguments, returns a string\n      args: [],\n      returns: FFIType.cstring,\n    },\n  },\n);\n\nconsole.log(`SQLite 3 version: ${sqlite3_libversion()}`);\n```\n\n## Performance\n\nAccording to [our benchmark](https://github.com/oven-sh/bun/tree/main/bench/ffi), `bun:ffi` is roughly 2-6x faster than Node.js FFI via `Node-API`.\n\n{% image src=\"/images/ffi.png\" height=\"400\" /%}\n\nBun generates & just-in-time compiles C bindings that efficiently convert values between JavaScript types and native types. To compile C, Bun embeds [TinyCC](https://github.com/TinyCC/tinycc), a small and fast C compiler.\n\n## Usage\n\n### Zig\n\n```zig\n// add.zig\npub export fn add(a: i32, b: i32) i32 {\n  return a + b;\n}\n```\n\nTo compile:\n\n```bash\n$ zig build-lib add.zig -dynamic -OReleaseFast\n```\n\nPass a path to the shared library and a map of symbols to import into `dlopen`:\n\n```ts\nimport { dlopen, FFIType, suffix } from \"bun:ffi\";\n\nconst path = `libadd.${suffix}`;\n\nconst lib = dlopen(path, {\n  add: {\n    args: [FFIType.i32, FFIType.i32],\n    returns: FFIType.i32,\n  },\n});\n\nlib.symbols.add(1, 2);\n```\n\n### Rust\n\n```rust\n// add.rs\n#[no_mangle]\npub extern \"C\" fn add(a: isize, b: isize) -> isize {\n    a + b\n}\n```\n\nTo compile:\n\n```bash\n$ rustc --crate-type cdylib add.rs\n```\n\n## FFI types\n\nThe following `FFIType` values are supported.\n\n| `FFIType` | C Type         | Aliases                     |\n| --------- | -------------- | --------------------------- |\n| cstring   | `char*`        |                             |\n| function  | `(void*)(*)()` | `fn`, `callback`            |\n| ptr       | `void*`        | `pointer`, `void*`, `char*` |\n| i8        | `int8_t`       | `int8_t`                    |\n| i16       | `int16_t`      | `int16_t`                   |\n| i32       | `int32_t`      | `int32_t`, `int`            |\n| i64       | `int64_t`      | `int64_t`                   |\n| i64_fast  | `int64_t`      |                             |\n| u8        | `uint8_t`      | `uint8_t`                   |\n| u16       | `uint16_t`     | `uint16_t`                  |\n| u32       | `uint32_t`     | `uint32_t`                  |\n| u64       | `uint64_t`     | `uint64_t`                  |\n| u64_fast  | `uint64_t`     |                             |\n| f32       | `float`        | `float`                     |\n| f64       | `double`       | `double`                    |\n| bool      | `bool`         |                             |\n| char      | `char`         |                             |\n\n## Strings\n\nJavaScript strings and C-like strings are different, and that complicates using strings with native libraries.\n\n{% details summary=\"How are JavaScript strings and C strings different?\" %}\nJavaScript strings:\n\n- UTF16 (2 bytes per letter) or potentially latin1, depending on the JavaScript engine &amp; what characters are used\n- `length` stored separately\n- Immutable\n\nC strings:\n\n- UTF8 (1 byte per letter), usually\n- The length is not stored. Instead, the string is null-terminated which means the length is the index of the first `\\0` it finds\n- Mutable\n\n{% /details %}\n\nTo solve this, `bun:ffi` exports `CString` which extends JavaScript's built-in `String` to support null-terminated strings and add a few extras:\n\n```ts\nclass CString extends String {\n  /**\n   * Given a `ptr`, this will automatically search for the closing `\\0` character and transcode from UTF-8 to UTF-16 if necessary.\n   */\n  constructor(ptr: number, byteOffset?: number, byteLength?: number): string;\n\n  /**\n   * The ptr to the C string\n   *\n   * This `CString` instance is a clone of the string, so it\n   * is safe to continue using this instance after the `ptr` has been\n   * freed.\n   */\n  ptr: number;\n  byteOffset?: number;\n  byteLength?: number;\n}\n```\n\nTo convert from a null-terminated string pointer to a JavaScript string:\n\n```ts\nconst myString = new CString(ptr);\n```\n\nTo convert from a pointer with a known length to a JavaScript string:\n\n```ts\nconst myString = new CString(ptr, 0, byteLength);\n```\n\nThe `new CString()` constructor clones the C string, so it is safe to continue using `myString` after `ptr` has been freed.\n\n```ts\nmy_library_free(myString.ptr);\n\n// this is safe because myString is a clone\nconsole.log(myString);\n```\n\nWhen used in `returns`, `FFIType.cstring` coerces the pointer to a JavaScript `string`. When used in `args`, `FFIType.cstring` is identical to `ptr`.\n\n## Function pointers\n\n{% callout %}\n\n**Note** \u2014 Async functions are not yet supported.\n\n{% /callout %}\n\nTo call a function pointer from JavaScript, use `CFunction`. This is useful if using Node-API (napi) with Bun, and you've already loaded some symbols.\n\n```ts\nimport { CFunction } from \"bun:ffi\";\n\nlet myNativeLibraryGetVersion = /* somehow, you got this pointer */\n\nconst getVersion = new CFunction({\n  returns: \"cstring\",\n  args: [],\n  ptr: myNativeLibraryGetVersion,\n});\ngetVersion();\n```\n\nIf you have multiple function pointers, you can define them all at once with `linkSymbols`:\n\n```ts\nimport { linkSymbols } from \"bun:ffi\";\n\n// getVersionPtrs defined elsewhere\nconst [majorPtr, minorPtr, patchPtr] = getVersionPtrs();\n\nconst lib = linkSymbols({\n  // Unlike with dlopen(), the names here can be whatever you want\n  getMajor: {\n    returns: \"cstring\",\n    args: [],\n\n    // Since this doesn't use dlsym(), you have to provide a valid ptr\n    // That ptr could be a number or a bigint\n    // An invalid pointer will crash your program.\n    ptr: majorPtr,\n  },\n  getMinor: {\n    returns: \"cstring\",\n    args: [],\n    ptr: minorPtr,\n  },\n  getPatch: {\n    returns: \"cstring\",\n    args: [],\n    ptr: patchPtr,\n  },\n});\n\nconst [major, minor, patch] = [lib.symbols.getMajor(), lib.symbols.getMinor(), lib.symbols.getPatch()];\n```\n\n## Callbacks\n\nUse `JSCallback` to create JavaScript callback functions that can be passed to C/FFI functions. The C/FFI function can call into the JavaScript/TypeScript code. This is useful for asynchronous code or whenever you want to call into JavaScript code from C.\n\n```ts\nimport { dlopen, JSCallback, ptr, CString } from \"bun:ffi\";\n\nconst {\n  symbols: { search },\n  close,\n} = dlopen(\"libmylib\", {\n  search: {\n    returns: \"usize\",\n    args: [\"cstring\", \"callback\"],\n  },\n});\n\nconst searchIterator = new JSCallback((ptr, length) => /hello/.test(new CString(ptr, length)), {\n  returns: \"bool\",\n  args: [\"ptr\", \"usize\"],\n});\n\nconst str = Buffer.from(\"wwutwutwutwutwutwutwutwutwutwutut\\0\", \"utf8\");\nif (search(ptr(str), searchIterator)) {\n  // found a match!\n}\n\n// Sometime later:\nsetTimeout(() => {\n  searchIterator.close();\n  close();\n}, 5000);\n```\n\nWhen you're done with a JSCallback, you should call `close()` to free the memory.\n\n{% callout %}\n\n**\u26a1\ufe0f Performance tip** \u2014 For a slight performance boost, directly pass `JSCallback.prototype.ptr` instead of the `JSCallback` object:\n\n```ts\nconst onResolve = new JSCallback(arg => arg === 42, {\n  returns: \"bool\",\n  args: [\"i32\"],\n});\nconst setOnResolve = new CFunction({\n  returns: \"bool\",\n  args: [\"function\"],\n  ptr: myNativeLibrarySetOnResolve,\n});\n\n// This code runs slightly faster:\nsetOnResolve(onResolve.ptr);\n\n// Compared to this:\nsetOnResolve(onResolve);\n```\n\n{% /callout %}\n\n## Pointers\n\nBun represents [pointers](<https://en.wikipedia.org/wiki/Pointer_(computer_programming)>) as a `number` in JavaScript.\n\n{% details summary=\"How does a 64 bit pointer fit in a JavaScript number?\" %}\n64-bit processors support up to [52 bits of addressable space](https://en.wikipedia.org/wiki/64-bit_computing#Limits_of_processors). [JavaScript numbers](https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64) support 53 bits of usable space, so that leaves us with about 11 bits of extra space.\n\n**Why not `BigInt`?** `BigInt` is slower. JavaScript engines allocate a separate `BigInt` which means they can't fit into a regular JavaScript value. If you pass a `BigInt` to a function, it will be converted to a `number`\n{% /details %}\n\nTo convert from a `TypedArray` to a pointer:\n\n```ts\nimport { ptr } from \"bun:ffi\";\nlet myTypedArray = new Uint8Array(32);\nconst myPtr = ptr(myTypedArray);\n```\n\nTo convert from a pointer to an `ArrayBuffer`:\n\n```ts\nimport { ptr, toArrayBuffer } from \"bun:ffi\";\nlet myTypedArray = new Uint8Array(32);\nconst myPtr = ptr(myTypedArray);\n\n// toArrayBuffer accepts a `byteOffset` and `byteLength`\n// if `byteLength` is not provided, it is assumed to be a null-terminated pointer\nmyTypedArray = new Uint8Array(toArrayBuffer(myPtr, 0, 32), 0, 32);\n```\n\nTo read data from a pointer, you have two options. For long-lived pointers, use a `DataView`:\n\n```ts\nimport { toArrayBuffer } from \"bun:ffi\";\nlet myDataView = new DataView(toArrayBuffer(myPtr, 0, 32));\n\nconsole.log(\n  myDataView.getUint8(0, true),\n  myDataView.getUint8(1, true),\n  myDataView.getUint8(2, true),\n  myDataView.getUint8(3, true),\n);\n```\n\nFor short-lived pointers, use `read`:\n\n```ts\nimport { read } from \"bun:ffi\";\n\nconsole.log(\n  // ptr, byteOffset\n  read.u8(myPtr, 0),\n  read.u8(myPtr, 1),\n  read.u8(myPtr, 2),\n  read.u8(myPtr, 3),\n);\n```\n\nThe `read` function behaves similarly to `DataView`, but it's usually faster because it doesn't need to create a `DataView` or `ArrayBuffer`.\n\n| `FFIType` | `read` function |\n| --------- | --------------- |\n| ptr       | `read.ptr`      |\n| i8        | `read.i8`       |\n| i16       | `read.i16`      |\n| i32       | `read.i32`      |\n| i64       | `read.i64`      |\n| u8        | `read.u8`       |\n| u16       | `read.u16`      |\n| u32       | `read.u32`      |\n| u64       | `read.u64`      |\n| f32       | `read.f32`      |\n| f64       | `read.f64`      |\n\n### Memory management\n\n`bun:ffi` does not manage memory for you. You must free the memory when you're done with it.\n\n#### From JavaScript\n\nIf you want to track when a `TypedArray` is no longer in use from JavaScript, you can use a [FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry).\n\n#### From C, Rust, Zig, etc\n\n{% callout %}\n**Note** \u2014 Available in Bun v0.1.8 and later.\n{% /callout %}\n\nIf you want to track when a `TypedArray` is no longer in use from C or FFI, you can pass a callback and an optional context pointer to `toArrayBuffer` or `toBuffer`. This function is called at some point later, once the garbage collector frees the underlying `ArrayBuffer` JavaScript object.\n\nThe expected signature is the same as in [JavaScriptCore's C API](https://developer.apple.com/documentation/javascriptcore/jstypedarraybytesdeallocator?language=objc):\n\n```c\ntypedef void (*JSTypedArrayBytesDeallocator)(void *bytes, void *deallocatorContext);\n```\n\n```ts\nimport { toArrayBuffer } from \"bun:ffi\";\n\n// with a deallocatorContext:\ntoArrayBuffer(\n  bytes,\n  byteOffset,\n\n  byteLength,\n\n  // this is an optional pointer to a callback\n  deallocatorContext,\n\n  // this is a pointer to a function\n  jsTypedArrayBytesDeallocator,\n);\n\n// without a deallocatorContext:\ntoArrayBuffer(\n  bytes,\n  byteOffset,\n\n  byteLength,\n\n  // this is a pointer to a function\n  jsTypedArrayBytesDeallocator,\n);\n```\n\n### Memory safety\n\nUsing raw pointers outside of FFI is extremely not recommended. A future version of Bun may add a CLI flag to disable `bun:ffi`.\n\n### Pointer alignment\n\nIf an API expects a pointer sized to something other than `char` or `u8`, make sure the `TypedArray` is also that size. A `u64*` is not exactly the same as `[8]u8*` due to alignment.\n\n### Passing a pointer\n\nWhere FFI functions expect a pointer, pass a `TypedArray` of equivalent size:\n\n```ts\nimport { dlopen, FFIType } from \"bun:ffi\";\n\nconst {\n  symbols: { encode_png },\n} = dlopen(myLibraryPath, {\n  encode_png: {\n    // FFIType's can be specified as strings too\n    args: [\"ptr\", \"u32\", \"u32\"],\n    returns: FFIType.ptr,\n  },\n});\n\nconst pixels = new Uint8ClampedArray(128 * 128 * 4);\npixels.fill(254);\npixels.subarray(0, 32 * 32 * 2).fill(0);\n\nconst out = encode_png(\n  // pixels will be passed as a pointer\n  pixels,\n\n  128,\n  128,\n);\n```\n\nThe [auto-generated wrapper](https://github.com/oven-sh/bun/blob/6a65631cbdcae75bfa1e64323a6ad613a922cd1a/src/bun.js/ffi.exports.js#L180-L182) converts the pointer to a `TypedArray`.\n\n{% details summary=\"Hardmode\" %}\n\nIf you don't want the automatic conversion or you want a pointer to a specific byte offset within the `TypedArray`, you can also directly get the pointer to the `TypedArray`:\n\n```ts\nimport { dlopen, FFIType, ptr } from \"bun:ffi\";\n\nconst {\n  symbols: { encode_png },\n} = dlopen(myLibraryPath, {\n  encode_png: {\n    // FFIType's can be specified as strings too\n    args: [\"ptr\", \"u32\", \"u32\"],\n    returns: FFIType.ptr,\n  },\n});\n\nconst pixels = new Uint8ClampedArray(128 * 128 * 4);\npixels.fill(254);\n\n// this returns a number! not a BigInt!\nconst myPtr = ptr(pixels);\n\nconst out = encode_png(\n  myPtr,\n\n  // dimensions:\n  128,\n  128,\n);\n```\n\n{% /details %}\n\n### Reading pointers\n\n```ts\nconst out = encode_png(\n  // pixels will be passed as a pointer\n  pixels,\n\n  // dimensions:\n  128,\n  128,\n);\n\n// assuming it is 0-terminated, it can be read like this:\nlet png = new Uint8Array(toArrayBuffer(out));\n\n// save it to disk:\nawait Bun.write(\"out.png\", png);\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/file Io instructions from the following content:"}, {"role": "assistant", "content": "{% callout %}\n\n<!-- **Note** \u2014 The `Bun.file` and `Bun.write` APIs documented on this page are heavily optimized and represent the recommended way to perform file-system tasks using Bun. Existing Node.js projects may use Bun's [nearly complete](/docs/runtime/nodejs-apis#node-fs) implementation of the [`node:fs`](https://nodejs.org/api/fs.html) module. -->\n\n**Note** \u2014 The `Bun.file` and `Bun.write` APIs documented on this page are heavily optimized and represent the recommended way to perform file-system tasks using Bun. For operations that are not yet available with `Bun.file`, such as `mkdir`, you can use Bun's [nearly complete](/docs/runtime/nodejs-apis#node-fs) implementation of the [`node:fs`](https://nodejs.org/api/fs.html) module.\n\n{% /callout %}\n\nBun provides a set of optimized APIs for reading and writing files.\n\n## Reading files (`Bun.file()`)\n\n`Bun.file(path): BunFile`\n\nCreate a `BunFile` instance with the `Bun.file(path)` function. A `BunFile` represents a lazily-loaded file; initializing it does not actually read the file from disk.\n\n```ts\nconst foo = Bun.file(\"foo.txt\"); // relative to cwd\nfoo.size; // number of bytes\nfoo.type; // MIME type\n```\n\nThe reference conforms to the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) interface, so the contents can be read in various formats.\n\n```ts\nconst foo = Bun.file(\"foo.txt\");\n\nawait foo.text(); // contents as a string\nawait foo.stream(); // contents as ReadableStream\nawait foo.arrayBuffer(); // contents as ArrayBuffer\n```\n\nFile references can also be created using numerical [file descriptors](https://en.wikipedia.org/wiki/File_descriptor) or `file://` URLs.\n\n```ts\nBun.file(1234);\nBun.file(new URL(import.meta.url)); // reference to the current file\n```\n\nA `BunFile` can point to a location on disk where a file does not exist.\n\n```ts\nconst notreal = Bun.file(\"notreal.txt\");\nnotreal.size; // 0\nnotreal.type; // \"text/plain;charset=utf-8\"\n```\n\nThe default MIME type is `text/plain;charset=utf-8`, but it can be overridden by passing a second argument to `Bun.file`.\n\n```ts\nconst notreal = Bun.file(\"notreal.json\", { type: \"application/json\" });\nnotreal.type; // => \"application/json;charset=utf-8\"\n```\n\nFor convenience, Bun exposes `stdin`, `stdout` and `stderr` as instances of `BunFile`.\n\n```ts\nBun.stdin; // readonly\nBun.stdout;\nBun.stderr;\n```\n\n## Writing files (`Bun.write()`)\n\n`Bun.write(destination, data): Promise<number>`\n\nThe `Bun.write` function is a multi-tool for writing payloads of all kinds to disk.\n\nThe first argument is the `destination` which can have any of the following types:\n\n- `string`: A path to a location on the file system. Use the `\"path\"` module to manipulate paths.\n- `URL`: A `file://` descriptor.\n- `BunFile`: A file reference.\n\nThe second argument is the data to be written. It can be any of the following:\n\n- `string`\n- `Blob` (including `BunFile`)\n- `ArrayBuffer` or `SharedArrayBuffer`\n- `TypedArray` (`Uint8Array`, et. al.)\n- `Response`\n\nAll possible permutations are handled using the fastest available system calls on the current platform.\n\n{% details summary=\"See syscalls\" %}\n\n{% table %}\n\n- Output\n- Input\n- System call\n- Platform\n\n---\n\n- file\n- file\n- copy_file_range\n- Linux\n\n---\n\n- file\n- pipe\n- sendfile\n- Linux\n\n---\n\n- pipe\n- pipe\n- splice\n- Linux\n\n---\n\n- terminal\n- file\n- sendfile\n- Linux\n\n---\n\n- terminal\n- terminal\n- sendfile\n- Linux\n\n---\n\n- socket\n- file or pipe\n- sendfile (if http, not https)\n- Linux\n\n---\n\n- file (doesn't exist)\n- file (path)\n- clonefile\n- macOS\n\n---\n\n- file (exists)\n- file\n- fcopyfile\n- macOS\n\n---\n\n- file\n- Blob or string\n- write\n- macOS\n\n---\n\n- file\n- Blob or string\n- write\n- Linux\n\n{% /table %}\n\n{% /details %}\n\nTo write a string to disk:\n\n```ts\nconst data = `It was the best of times, it was the worst of times.`;\nawait Bun.write(\"output.txt\", data);\n```\n\nTo copy a file to another location on disk:\n\n```js\nconst input = Bun.file(\"input.txt\");\nconst output = Bun.file(\"output.txt\"); // doesn't exist yet!\nawait Bun.write(output, input);\n```\n\nTo write a byte array to disk:\n\n```ts\nconst encoder = new TextEncoder();\nconst data = encoder.encode(\"datadatadata\"); // Uint8Array\nawait Bun.write(\"output.txt\", data);\n```\n\nTo write a file to `stdout`:\n\n```ts\nconst input = Bun.file(\"input.txt\");\nawait Bun.write(Bun.stdout, input);\n```\n\nTo write an HTTP response to disk:\n\n```ts\nconst response = await fetch(\"https://bun.sh\");\nawait Bun.write(\"index.html\", response);\n```\n\n## Incremental writing with `FileSink`\n\nBun provides a native incremental file writing API called `FileSink`. To retrieve a `FileSink` instance from a `BunFile`:\n\n```ts\nconst file = Bun.file(\"output.txt\");\nconst writer = file.writer();\n```\n\nTo incrementally write to the file, call `.write()`.\n\n```ts\nconst file = Bun.file(\"output.txt\");\nconst writer = file.writer();\n\nwriter.write(\"it was the best of times\\n\");\nwriter.write(\"it was the worst of times\\n\");\n```\n\nThese chunks will be buffered internally. To flush the buffer to disk, use `.flush()`. This returns the number of flushed bytes.\n\n```ts\nwriter.flush(); // write buffer to disk\n```\n\nThe buffer will also auto-flush when the `FileSink`'s _high water mark_ is reached; that is, when its internal buffer is full. This value can be configured.\n\n```ts\nconst file = Bun.file(\"output.txt\");\nconst writer = file.writer({ highWaterMark: 1024 * 1024 }); // 1MB\n```\n\nTo flush the buffer and close the file:\n\n```ts\nwriter.end();\n```\n\nNote that, by default, the `bun` process will stay alive until this `FileSink` is explicitly closed with `.end()`. To opt out of this behavior, you can \"unref\" the instance.\n\n```ts\nwriter.unref();\n\n// to \"re-ref\" it later\nwriter.ref();\n```\n\n## Benchmarks\n\nThe following is a 3-line implementation of the Linux `cat` command.\n\n```ts#cat.ts\n// Usage\n// $ bun ./cat.ts ./path-to-file\n\nimport { resolve } from \"path\";\n\nconst path = resolve(process.argv.at(-1));\nawait Bun.write(Bun.stdout, Bun.file(path));\n```\n\nTo run the file:\n\n```bash\n$ bun ./cat.ts ./path-to-file\n```\n\nIt runs 2x faster than GNU `cat` for large files on Linux.\n\n{% image src=\"/images/cat.jpg\" /%}\n\n## Reference\n\n```ts\ninterface Bun {\n  stdin: BunFile;\n  stdout: BunFile;\n  stderr: BunFile;\n\n  file(path: string | number | URL, options?: { type?: string }): BunFile;\n\n  write(\n    destination: string | number | BunFile | URL,\n    input:\n      | string\n      | Blob\n      | ArrayBuffer\n      | SharedArrayBuffer\n      | TypedArray\n      | Response,\n  ): Promise<number>;\n}\n\ninterface BunFile {\n  readonly size: number;\n  readonly type: string;\n\n  text(): Promise<string>;\n  stream(): Promise<ReadableStream>;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  json(): Promise<any>;\n  writer(params: { highWaterMark?: number }): FileSink;\n}\n\nexport interface FileSink {\n  write(\n    chunk: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n  ): number;\n  flush(): number | Promise<number>;\n  end(error?: Error): number | Promise<number>;\n  start(options?: { highWaterMark?: number }): void;\n  ref(): void;\n  unref(): void;\n}\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/file System Router instructions from the following content:"}, {"role": "assistant", "content": "Bun provides a fast API for resolving routes against file-system paths. This API is primarily intended for library authors. At the moment only Next.js-style file-system routing is supported, but other styles may be added in the future.\n\n## Next.js-style\n\nThe `FileSystemRouter` class can resolve routes against a `pages` directory. (The Next.js 13 `app` directory is not yet supported.) Consider the following `pages` directory:\n\n```txt\npages\n\u251c\u2500\u2500 index.tsx\n\u251c\u2500\u2500 settings.tsx\n\u251c\u2500\u2500 blog\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 [slug].tsx\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.tsx\n\u2514\u2500\u2500 [[...catchall]].tsx\n```\n\nThe `FileSystemRouter` can be used to resolve routes against this directory:\n\n```ts\nconst router = new Bun.FileSystemRouter({\n  style: \"nextjs\",\n  dir: \"./pages\",\n  origin: \"https://mydomain.com\",\n  assetPrefix: \"_next/static/\"\n});\nrouter.match(\"/\");\n\n// =>\n{\n  filePath: \"/path/to/pages/index.tsx\",\n  kind: \"exact\",\n  name: \"/\",\n  pathname: \"/\",\n  src: \"https://mydomain.com/_next/static/pages/index.tsx\"\n}\n```\n\nQuery parameters will be parsed and returned in the `query` property.\n\n```ts\nrouter.match(\"/settings?foo=bar\");\n\n// =>\n{\n  filePath: \"/Users/colinmcd94/Documents/bun/fun/pages/settings.tsx\",\n  kind: \"dynamic\",\n  name: \"/settings\",\n  pathname: \"/settings?foo=bar\",\n  src: \"https://mydomain.com/_next/static/pages/settings.tsx\"\n  query: {\n    foo: \"bar\"\n  }\n}\n```\n\nThe router will automatically parse URL parameters and return them in the `params` property:\n\n```ts\nrouter.match(\"/blog/my-cool-post\");\n\n// =>\n{\n  filePath: \"/Users/colinmcd94/Documents/bun/fun/pages/blog/[slug].tsx\",\n  kind: \"dynamic\",\n  name: \"/blog/[slug]\",\n  pathname: \"/blog/my-cool-post\",\n  src: \"https://mydomain.com/_next/static/pages/blog/[slug].tsx\"\n  params: {\n    slug: \"my-cool-post\"\n  }\n}\n```\n\nThe `.match()` method also accepts `Request` and `Response` objects. The `url` property will be used to resolve the route.\n\n```ts\nrouter.match(new Request(\"https://example.com/blog/my-cool-post\"));\n```\n\nThe router will read the directory contents on initialization. To re-scan the files, use the `.reload()` method.\n\n```ts\nrouter.reload();\n```\n\n## Reference\n\n```ts\ninterface Bun {\n  class FileSystemRouter {\n    constructor(params: {\n      dir: string;\n      style: \"nextjs\";\n      origin?: string;\n      assetPrefix?: string;\n    });\n\n    reload(): void;\n\n    match(path: string | Request | Response): {\n      filePath: string;\n      kind: \"exact\" | \"catch-all\" | \"optional-catch-all\" | \"dynamic\";\n      name: string;\n      pathname: string;\n      src: string;\n      params?: Record<string, string>;\n      query?: Record<string, string>;\n    } | null\n  }\n}\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/file instructions from the following content:"}, {"role": "assistant", "content": "Bun.js has fast paths for common use cases that make Web APIs live up to the performance demands of servers and CLIs.\n\n`Bun.file(path)` returns a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) that represents a lazily-loaded file.\n\nWhen you pass a file blob to `Bun.write`, Bun automatically uses a faster system call:\n\n```js\nconst blob = Bun.file(\"input.txt\");\nawait Bun.write(\"output.txt\", blob);\n```\n\nOn Linux, this uses the [`copy_file_range`](https://man7.org/linux/man-pages/man2/copy_file_range.2.html) syscall and on macOS, this becomes `clonefile` (or [`fcopyfile`](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/copyfile.3.html)).\n\n`Bun.write` also supports [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects. It automatically converts to a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n\n```js\n// Eventually, this will stream the response to disk but today it buffers\nawait Bun.write(\"index.html\", await fetch(\"https://example.com\"));\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/globals instructions from the following content:"}, {"role": "assistant", "content": "Bun implements the following globals.\n\n{% table %}\n\n- Global\n- Source\n- Notes\n\n---\n\n- [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n- Web\n- &nbsp;\n\n---\n\n- [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n- Web\n- &nbsp;\n\n---\n\n- [`alert`](https://developer.mozilla.org/en-US/docs/Web/API/Window/alert)\n- Web\n- Intended for command-line tools\n\n---\n\n- [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n- Web\n- &nbsp;\n\n---\n\n- [`Buffer`](https://nodejs.org/api/buffer.html#class-buffer)\n- Node.js\n- See [Node.js > `Buffer`](/docs/runtime/nodejs-apis#node-buffer)\n\n---\n\n- `Bun`\n- Bun\n- Subject to change as additional APIs are added\n\n---\n\n- [`ByteLengthQueuingStrategy`](https://developer.mozilla.org/en-US/docs/Web/API/ByteLengthQueuingStrategy)\n- Web\n- &nbsp;\n\n---\n\n- [`confirm`](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm)\n- Web\n- Intended for command-line tools\n\n---\n\n- [`__dirname`](https://nodejs.org/api/globals.html#__dirname)\n- Node.js\n- &nbsp;\n\n---\n\n- [`__filename`](https://nodejs.org/api/globals.html#__filename)\n- Node.js\n- &nbsp;\n\n---\n\n- [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob)\n- Web\n- &nbsp;\n\n---\n\n- [`btoa()`](https://developer.mozilla.org/en-US/docs/Web/API/btoa)\n- Web\n- &nbsp;\n\n---\n\n- `BuildMessage`\n- Bun\n- &nbsp;\n\n---\n\n- [`clearImmediate()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/clearImmediate)\n- Web\n- &nbsp;\n\n---\n\n- [`clearInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/clearInterval)\n- Web\n- &nbsp;\n\n---\n\n- [`clearTimeout()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/clearTimeout)\n- Web\n- &nbsp;\n\n---\n\n- [`console`](https://developer.mozilla.org/en-US/docs/Web/API/console)\n- Web\n- &nbsp;\n\n---\n\n- [`CountQueuingStrategy`](https://developer.mozilla.org/en-US/docs/Web/API/CountQueuingStrategy)\n- Web\n- &nbsp;\n\n---\n\n- [`Crypto`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto)\n- Web\n- &nbsp;\n\n---\n\n- [`crypto`](https://developer.mozilla.org/en-US/docs/Web/API/crypto)\n- Web\n- &nbsp;\n\n---\n\n- [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n- Web\n- &nbsp;\n\n---\n\n- [`CustomEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n- Web\n- &nbsp;\n\n---\n\n- [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event)\n- Web\n- Also [`ErrorEvent`](https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent) [`CloseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent) [`MessageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent).\n\n---\n\n- [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)\n- Web\n- &nbsp;\n\n---\n\n- [`exports`](https://nodejs.org/api/globals.html#exports)\n- Node.js\n- &nbsp;\n\n---\n\n- [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)\n- Web\n- &nbsp;\n\n---\n\n- [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n- Web\n- &nbsp;\n\n---\n\n- [`global`](https://nodejs.org/api/globals.html#global)\n- Node.js\n- See [Node.js > `global`](/docs/runtime/nodejs-apis#global).\n\n---\n\n- [`globalThis`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis)\n- Cross-platform\n- Aliases to `global`\n\n---\n\n- [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers)\n- Web\n- &nbsp;\n\n---\n\n- [`HTMLRewriter`](/docs/api/html-rewriter)\n- Cloudflare\n- &nbsp;\n\n---\n\n- [`JSON`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)\n- Web\n- &nbsp;\n\n---\n\n- [`MessageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent)\n- Web\n- &nbsp;\n\n---\n\n- [`module`](https://nodejs.org/api/globals.html#module)\n- Node.js\n- &nbsp;\n\n---\n\n- [`performance`](https://developer.mozilla.org/en-US/docs/Web/API/performance)\n- Web\n- &nbsp;\n\n---\n\n- [`process`](https://nodejs.org/api/process.html)\n- Node.js\n- See [Node.js > `process`](/docs/runtime/nodejs-apis#node-process)\n\n---\n\n- [`prompt`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt)\n- Web\n- Intended for command-line tools\n\n---\n\n- [`queueMicrotask()`](https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask)\n- Web\n- &nbsp;\n\n---\n\n- [`ReadableByteStreamController`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableByteStreamController)\n- Web\n- &nbsp;\n\n---\n\n- [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)\n- Web\n- &nbsp;\n\n---\n\n- [`ReadableStreamDefaultController`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController)\n- Web\n- &nbsp;\n\n---\n\n- [`ReadableStreamDefaultReader`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader)\n- Web\n- &nbsp;\n\n---\n\n- [`reportError`](https://developer.mozilla.org/en-US/docs/Web/API/reportError)\n- Web\n- &nbsp;\n\n---\n\n- [`require()`](https://nodejs.org/api/globals.html#require)\n- Node.js\n- &nbsp;\n\n---\n\n- `ResolveMessage`\n- Bun\n- &nbsp;\n\n---\n\n- [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n- Web\n- &nbsp;\n\n---\n\n- [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n- Web\n- &nbsp;\n\n---\n\n- [`setImmediate()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate)\n- Web\n- &nbsp;\n\n---\n\n- [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval)\n- Web\n- &nbsp;\n\n---\n\n- [`setTimeout()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout)\n- Web\n- &nbsp;\n\n---\n\n- [`ShadowRealm`](https://github.com/tc39/proposal-shadowrealm)\n- Web\n- Stage 3 proposal\n\n---\n\n- [`SubtleCrypto`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)\n- Web\n- &nbsp;\n\n---\n\n- [`DOMException`](https://developer.mozilla.org/en-US/docs/Web/API/DOMException)\n- Web\n- &nbsp;\n\n---\n\n- [`TextDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder)\n- Web\n- &nbsp;\n\n---\n\n- [`TextEncoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder)\n- Web\n- &nbsp;\n\n---\n\n- [`TransformStream`](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream)\n- Web\n- &nbsp;\n\n---\n\n- [`TransformStreamDefaultController`](https://developer.mozilla.org/en-US/docs/Web/API/TransformStreamDefaultController)\n- Web\n- &nbsp;\n\n---\n\n- [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL)\n- Web\n- &nbsp;\n\n---\n\n- [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n- Web\n- &nbsp;\n\n---\n\n- [`WebAssembly`](https://nodejs.org/api/globals.html#webassembly)\n- Web\n- &nbsp;\n\n---\n\n- [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream)\n- Web\n- &nbsp;\n\n---\n\n- [`WritableStreamDefaultController`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultController)\n- Web\n- &nbsp;\n\n---\n\n- [`WritableStreamDefaultWriter`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultWriter)\n- Web\n- &nbsp;\n\n{% /table %}\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/hashing instructions from the following content:"}, {"role": "assistant", "content": "{% callout %}\n\nBun implements the `createHash` and `createHmac` functions from [`node:crypto`](https://nodejs.org/api/crypto.html) in addition to the Bun-native APIs documented below.\n\n{% /callout %}\n\n## `Bun.password`\n\n{% callout %}\n**Note** \u2014 Added in Bun 0.6.8.\n{% /callout %}\n\n`Bun.password` is a collection of utility functions for hashing and verifying passwords with various cryptographically secure algorithms.\n\n```ts\nconst password = \"super-secure-pa$$word\";\n\nconst hash = await Bun.password.hash(password);\n// => $argon2id$v=19$m=65536,t=2,p=1$tFq+9AVr1bfPxQdh6E8DQRhEXg/M/SqYCNu6gVdRRNs$GzJ8PuBi+K+BVojzPfS5mjnC8OpLGtv8KJqF99eP6a4\n\nconst isMatch = await Bun.password.verify(password, hash);\n// => true\n```\n\nThe second argument to `Bun.password.hash` accepts a params object that lets you pick and configure the hashing algorithm.\n\n```ts\nconst password = \"super-secure-pa$$word\";\n\n// use argon2 (default)\nconst argonHash = await Bun.password.hash(password, {\n  algorithm: \"argon2id\", // \"argon2id\" | \"argon2i\" | \"argon2d\"\n  memoryCost: 4, // memory usage in kibibytes\n  timeCost: 3, // the number of iterations\n});\n\n// use bcrypt\nconst bcryptHash = await Bun.password.hash(password, {\n  algorithm: \"bcrypt\",\n  cost: 4, // number between 4-31\n});\n```\n\nThe algorithm used to create the hash is stored in the hash itself. When using `bcrypt`, the returned hash is encoded in [Modular Crypt Format](https://passlib.readthedocs.io/en/stable/modular_crypt_format.html) for compatibility with most existing `bcrypt` implementations; with `argon2` the result is encoded in the newer [PHC format](https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md).\n\nThe `verify` function automatically detects the algorithm based on the input hash and use the correct verification method. It can correctly infer the algorithm from both PHC- or MCF-encoded hashes.\n\n```ts\nconst password = \"super-secure-pa$$word\";\n\nconst hash = await Bun.password.hash(password, {\n  /* config */\n});\n\nconst isMatch = await Bun.password.verify(password, hash);\n// => true\n```\n\nSynchronous versions of all functions are also available. Keep in mind that these functions are computationally expensive, so using a blocking API may degrade application performance.\n\n```ts\nconst password = \"super-secure-pa$$word\";\n\nconst hash = Bun.password.hashSync(password, {\n  /* config */\n});\n\nconst isMatch = Bun.password.verifySync(password, hash);\n// => true\n```\n\n## `Bun.hash`\n\n`Bun.hash` is a collection of utilities for _non-cryptographic_ hashing. Non-cryptographic hashing algorithms are optimized for speed of computation over collision-resistance or security.\n\nThe standard `Bun.hash` functions uses [Wyhash](https://github.com/wangyi-fudan/wyhash) to generate a 64-bit hash from an input of arbitrary size.\n\n```ts\nBun.hash(\"some data here\");\n// 11562320457524636935n\n```\n\nThe input can be a string, `TypedArray`, `DataView`, `ArrayBuffer`, or `SharedArrayBuffer`.\n\n```ts\nconst arr = new Uint8Array([1, 2, 3, 4]);\n\nBun.hash(\"some data here\");\nBun.hash(arr);\nBun.hash(arr.buffer);\nBun.hash(new DataView(arr.buffer));\n```\n\nOptionally, an integer seed can be specified as the second parameter. For 64-bit hashes seeds above `Number.MAX_SAFE_INTEGER` should be given as BigInt to avoid loss of precision.\n\n```ts\nBun.hash(\"some data here\", 1234);\n// 15724820720172937558n\n```\n\nAdditional hashing algorithms are available as properties on `Bun.hash`. The API is the same for each, only changing the return type from number for 32-bit hashes to bigint for 64-bit hashes.\n\n```ts\nBun.hash.wyhash(\"data\", 1234); // equivalent to Bun.hash()\nBun.hash.crc32(\"data\", 1234);\nBun.hash.adler32(\"data\", 1234);\nBun.hash.cityHash32(\"data\", 1234);\nBun.hash.cityHash64(\"data\", 1234);\nBun.hash.murmur32v3(\"data\", 1234);\nBun.hash.murmur32v2(\"data\", 1234);\nBun.hash.murmur64v2(\"data\", 1234);\n```\n\n## `Bun.CryptoHasher`\n\n`Bun.CryptoHasher` is a general-purpose utility class that lets you incrementally compute a hash of string or binary data using a range of cryptographic hash algorithms. The following algorithms are supported:\n\n- `\"blake2b256\"`\n- `\"md4\"`\n- `\"md5\"`\n- `\"ripemd160\"`\n- `\"sha1\"`\n- `\"sha224\"`\n- `\"sha256\"`\n- `\"sha384\"`\n- `\"sha512\"`\n- `\"sha512-256\"`\n\n```ts\nconst hasher = new Bun.CryptoHasher(\"sha256\");\nhasher.update(\"hello world\");\nhasher.digest();\n// Uint8Array(32) [ <byte>, <byte>, ... ]\n```\n\nOnce initialized, data can be incrementally fed to to the hasher using `.update()`. This method accepts `string`, `TypedArray`, and `ArrayBuffer`.\n\n```ts\nconst hasher = new Bun.CryptoHasher();\n\nhasher.update(\"hello world\");\nhasher.update(new Uint8Array([1, 2, 3]));\nhasher.update(new ArrayBuffer(10));\n```\n\nIf a `string` is passed, an optional second parameter can be used to specify the encoding (default `'utf-8'`). The following encodings are supported:\n\n{% table %}\n\n---\n\n- Binary encodings\n- `\"base64\"` `\"base64url\"` `\"hex\"` `\"binary\"`\n\n---\n\n- Character encodings\n- `\"utf8\"` `\"utf-8\"` `\"utf16le\"` `\"latin1\"`\n\n---\n\n- Legacy character encodings\n- `\"ascii\"` `\"binary\"` `\"ucs2\"` `\"ucs-2\"`\n\n{% /table %}\n\n```ts\nhasher.update(\"hello world\"); // defaults to utf8\nhasher.update(\"hello world\", \"hex\");\nhasher.update(\"hello world\", \"base64\");\nhasher.update(\"hello world\", \"latin1\");\n```\n\nAfter the data has been feed into the hasher, a final hash can be computed using `.digest()`. By default, this method returns a `Uint8Array` containing the hash.\n\n```ts\nconst hasher = new Bun.CryptoHasher();\nhasher.update(\"hello world\");\n\nhasher.digest();\n// => Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]\n```\n\nThe `.digest()` method can optionally return the hash as a string. To do so, specify an encoding:\n\n```ts\nhasher.digest(\"base64\");\n// => \"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek=\"\n\nhasher.digest(\"hex\");\n// => \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\"\n```\n\nAlternatively, the method can write the hash into a pre-existing `TypedArray` instance. This may be desirable in some performance-sensitive applications.\n\n```ts\nconst arr = new Uint8Array(32);\n\nhasher.digest(arr);\n\nconsole.log(arr);\n// => Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]\n```\n\n<!-- Bun.sha; -->\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/html Rewriter instructions from the following content:"}, {"role": "assistant", "content": "Bun provides a fast native implementation of the `HTMLRewriter` pattern developed by Cloudflare. It provides a convenient, `EventListener`-like API for traversing and transforming HTML documents.\n\n```ts\nconst rewriter = new HTMLRewriter();\n\nrewriter.on(\"*\", {\n  element(el) {\n    console.log(el.tagName); // \"body\" | \"div\" | ...\n  },\n});\n```\n\nTo parse and/or transform the HTML:\n\n```ts#rewriter.ts\nrewriter.transform(\n  new Response(`\n<!DOCTYPE html>\n<html>\n<!-- comment -->\n<head>\n  <title>My First HTML Page</title>\n</head>\n<body>\n  <h1>My First Heading</h1>\n  <p>My first paragraph.</p>\n</body>\n`));\n```\n\nView the full documentation on the [Cloudflare website](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/).\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/http instructions from the following content:"}, {"role": "assistant", "content": "The page primarily documents the Bun-native `Bun.serve` API. Bun also implements [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) and the Node.js [`http`](https://nodejs.org/api/http.html) and [`https`](https://nodejs.org/api/https.html) modules.\n\n{% callout %}\nThese modules have been re-implemented to use Bun's fast internal HTTP infrastructure. Feel free to use these modules directly; frameworks like [Express](https://expressjs.com/) that depend on these modules should work out of the box. For granular compatibility information, see [Runtime > Node.js APIs](/docs/runtime/nodejs-apis).\n{% /callout %}\n\nTo start a high-performance HTTP server with a clean API, the recommended approach is [`Bun.serve`](#start-a-server-bun-serve).\n\n## `Bun.serve()`\n\nStart an HTTP server in Bun with `Bun.serve`.\n\n```ts\nBun.serve({\n  fetch(req) {\n    return new Response(`Bun!`);\n  },\n});\n```\n\nThe `fetch` handler handles incoming requests. It receives a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object and returns a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) or `Promise<Response>`.\n\n```ts\nBun.serve({\n  fetch(req) {\n    const url = new URL(req.url);\n    if (url.pathname === \"/\") return new Response(`Home page!`);\n    if (url.pathname === \"/blog\") return new Response(\"Blog!\");\n    return new Response(`404!`);\n  },\n});\n```\n\nTo configure which port and hostname the server will listen on:\n\n```ts\nBun.serve({\n  port: 8080, // defaults to $BUN_PORT, $PORT, $NODE_PORT otherwise 3000\n  hostname: \"mydomain.com\", // defaults to \"0.0.0.0\"\n  fetch(req) {\n    return new Response(`404!`);\n  },\n});\n```\n\nTo listen on a [unix domain socket](https://en.wikipedia.org/wiki/Unix_domain_socket):\n\n```ts\nBun.serve({\n  unix: \"/tmp/my-socket.sock\", // path to socket\n  fetch(req) {\n    return new Response(`404!`);\n  },\n});\n```\n\n## Error handling\n\nTo activate development mode, set `development: true`. By default, development mode is _enabled_ unless `NODE_ENV` is `production`.\n\n```ts\nBun.serve({\n  development: true,\n  fetch(req) {\n    throw new Error(\"woops!\");\n  },\n});\n```\n\nIn development mode, Bun will surface errors in-browser with a built-in error page.\n\n{% image src=\"/images/exception_page.png\" caption=\"Bun's built-in 500 page\" /%}\n\nTo handle server-side errors, implement an `error` handler. This function should return a `Response` to served to the client when an error occurs. This response will supercede Bun's default error page in `development` mode.\n\n```ts\nBun.serve({\n  fetch(req) {\n    throw new Error(\"woops!\");\n  },\n  error(error) {\n    return new Response(`<pre>${error}\\n${error.stack}</pre>`, {\n      headers: {\n        \"Content-Type\": \"text/html\",\n      },\n    });\n  },\n});\n```\n\n{% callout %}\n[Learn more about debugging in Bun](https://bun.sh/docs/runtime/debugger)\n{% /callout %}\n\nThe call to `Bun.serve` returns a `Server` object. To stop the server, call the `.stop()` method.\n\n```ts\nconst server = Bun.serve({\n  fetch() {\n    return new Response(\"Bun!\");\n  },\n});\n\nserver.stop();\n```\n\n## TLS\n\nBun supports TLS out of the box, powered by [BoringSSL](https://boringssl.googlesource.com/boringssl). Enable TLS by passing in a value for `key` and `cert`; both are required to enable TLS.\n\n```ts-diff\n  Bun.serve({\n    fetch(req) {\n      return new Response(\"Hello!!!\");\n    },\n\n+   tls: {\n+     key: Bun.file(\"./key.pem\"),\n+     cert: Bun.file(\"./cert.pem\"),\n+   }\n  });\n```\n\nThe `key` and `cert` fields expect the _contents_ of your TLS key and certificate, _not a path to it_. This can be a string, `BunFile`, `TypedArray`, or `Buffer`.\n\n```ts\nBun.serve({\n  fetch() {},\n\n  tls: {\n    // BunFile\n    key: Bun.file(\"./key.pem\"),\n    // Buffer\n    key: fs.readFileSync(\"./key.pem\"),\n    // string\n    key: fs.readFileSync(\"./key.pem\", \"utf8\"),\n    // array of above\n    key: [Bun.file(\"./key1.pem\"), Bun.file(\"./key2.pem\")],\n  },\n});\n```\n\n{% callout %}\n\n**Note** \u2014\u00a0Earlier versions of Bun supported passing a file path as `keyFile` and `certFile`; this has been deprecated as of `v0.6.3`.\n\n{% /callout %}\n\nIf your private key is encrypted with a passphrase, provide a value for `passphrase` to decrypt it.\n\n```ts-diff\n  Bun.serve({\n    fetch(req) {\n      return new Response(\"Hello!!!\");\n    },\n\n    tls: {\n      key: Bun.file(\"./key.pem\"),\n      cert: Bun.file(\"./cert.pem\"),\n+     passphrase: \"my-secret-passphrase\",\n    }\n  });\n```\n\nOptionally, you can override the trusted CA certificates by passing a value for `ca`. By default, the server will trust the list of well-known CAs curated by Mozilla. When `ca` is specified, the Mozilla list is overwritten.\n\n```ts-diff\n  Bun.serve({\n    fetch(req) {\n      return new Response(\"Hello!!!\");\n    },\n    tls: {\n      key: Bun.file(\"./key.pem\"), // path to TLS key\n      cert: Bun.file(\"./cert.pem\"), // path to TLS cert\n+     ca: Bun.file(\"./ca.pem\"), // path to root CA certificate\n    }\n  });\n```\n\nTo override Diffie-Helman parameters:\n\n```ts\nBun.serve({\n  // ...\n  tls: {\n    // other config\n    dhParamsFile: \"/path/to/dhparams.pem\", // path to Diffie Helman parameters\n  },\n});\n```\n\n## Object syntax\n\nThus far, the examples on this page have used the explicit `Bun.serve` API. Bun also supports an alternate syntax.\n\n```ts#server.ts\nimport {type Serve} from \"bun\";\n\nexport default {\n  fetch(req) {\n    return new Response(`Bun!`);\n  },\n} satisfies Serve;\n```\n\nInstead of passing the server options into `Bun.serve`, `export default` it. This file can be executed as-is; when Bun sees a file with a `default` export containing a `fetch` handler, it passes it into `Bun.serve` under the hood.\n\n<!-- This syntax has one major advantage: it is hot-reloadable out of the box. When any source file is changed, Bun will reload the server with the updated code _without restarting the process_. This makes hot reloads nearly instantaneous. Use the `--hot` flag when starting the server to enable hot reloading. -->\n\n<!-- ```bash\n$ bun --hot server.ts\n``` -->\n\n<!-- It's possible to configure hot reloading while using the explicit `Bun.serve` API; for details refer to [Runtime > Hot reloading](/docs/runtime/hot). -->\n\n## Streaming files\n\nTo stream a file, return a `Response` object with a `BunFile` object as the body.\n\n```ts\nimport { serve, file } from \"bun\";\n\nserve({\n  fetch(req) {\n    return new Response(Bun.file(\"./hello.txt\"));\n  },\n});\n```\n\n{% callout %}\n\u26a1\ufe0f **Speed** \u2014 Bun automatically uses the [`sendfile(2)`](https://man7.org/linux/man-pages/man2/sendfile.2.html) system call when possible, enabling zero-copy file transfers in the kernel\u2014the fastest way to send files.\n{% /callout %}\n\n**[v0.3.0+]** You can send part of a file using the [`slice(start, end)`](https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice) method on the `Bun.file` object. This automatically sets the `Content-Range` and `Content-Length` headers on the `Response` object.\n\n```ts\nBun.serve({\n  fetch(req) {\n    // parse `Range` header\n    const [start = 0, end = Infinity] = req.headers\n      .get(\"Range\") // Range: bytes=0-100\n      .split(\"=\") // [\"Range: bytes\", \"0-100\"]\n      .at(-1) // \"0-100\"\n      .split(\"-\") // [\"0\", \"100\"]\n      .map(Number); // [0, 100]\n\n    // return a slice of the file\n    const bigFile = Bun.file(\"./big-video.mp4\");\n    return new Response(bigFile.slice(start, end));\n  },\n});\n```\n\n## Benchmarks\n\nBelow are Bun and Node.js implementations of a simple HTTP server that responds `Bun!` to each incoming `Request`.\n\n{% codetabs %}\n\n```ts#Bun\nBun.serve({\n  fetch(req: Request) {\n    return new Response(`Bun!`);\n  },\n  port: 3000,\n});\n```\n\n```ts#Node\nrequire(\"http\")\n  .createServer((req, res) => res.end(\"Bun!\"))\n  .listen(8080);\n```\n\n{% /codetabs %}\nThe `Bun.serve` server can handle roughly 2.5x more requests per second than Node.js on Linux.\n\n{% table %}\n\n- Runtime\n- Requests per second\n\n---\n\n- Node 16\n- ~64,000\n\n---\n\n- Bun\n- ~160,000\n\n{% /table %}\n\n{% image width=\"499\" alt=\"image\" src=\"https://user-images.githubusercontent.com/709451/162389032-fc302444-9d03-46be-ba87-c12bd8ce89a0.png\" /%}\n\n## Reference\n\n{% details summary=\"See TypeScript definitions\" %}\n\n```ts\ninterface Bun {\n  serve(options: {\n    fetch: (req: Request, server: Server) => Response | Promise<Response>;\n    hostname?: string;\n    port?: number;\n    development?: boolean;\n    error?: (error: Error) => Response | Promise<Response>;\n    tls?: {\n      key?:\n        | string\n        | TypedArray\n        | BunFile\n        | Array<string | TypedArray | BunFile>;\n      cert?:\n        | string\n        | TypedArray\n        | BunFile\n        | Array<string | TypedArray | BunFile>;\n      ca?: string | TypedArray | BunFile | Array<string | TypedArray | BunFile>;\n      passphrase?: string;\n      dhParamsFile?: string;\n    };\n    maxRequestBodySize?: number;\n    lowMemoryMode?: boolean;\n  }): Server;\n}\n\ninterface Server {\n  development: boolean;\n  hostname: string;\n  port: number;\n  pendingRequests: number;\n  stop(): void;\n}\n```\n\n{% /details %}\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/import Meta instructions from the following content:"}, {"role": "assistant", "content": "The `import.meta` object is a way for a module to access information about itself. It's part of the JavaScript language, but its contents are not standardized. Each \"host\" (browser, runtime, etc) is free to implement any properties it wishes on the `import.meta` object.\n\nBun implements the following properties.\n\n```ts#/path/to/project/file.ts\nimport.meta.dir;   // => \"/path/to/project\"\nimport.meta.file;  // => \"file.ts\"\nimport.meta.path;  // => \"/path/to/project/file.ts\"\n\nimport.meta.main;  // `true` if this file is directly executed by `bun run`\n                   // `false` otherwise\n\nimport.meta.resolveSync(\"zod\")\n// resolve an import specifier relative to the directory\n```\n\n{% table %}\n\n---\n\n- `import.meta.dir`\n- Absolute path to the directory containing the current file, e.g. `/path/to/project`. Equivalent to `__dirname` in CommonJS modules (and Node.js)\n\n---\n\n- `import.meta.file`\n- The name of the current file, e.g. `index.tsx`\n\n---\n\n- `import.meta.path`\n- Absolute path to the current file, e.g. `/path/to/project/index.tx`. Equivalent to `__filename` in CommonJS modules (and Node.js)\n\n---\n\n- `import.meta.main`\n- `boolean` Indicates whether the current file is the entrypoint to the current `bun` process. Is the file being directly executed by `bun run` or is it being imported?\n\n---\n\n- `import.meta.resolve{Sync}`\n- Resolve a module specifier (e.g. `\"zod\"` or `\"./file.tsx`) to an absolute path. While file would be imported if the specifier were imported from this file?\n\n  ```ts\n  import.meta.resolveSync(\"zod\");\n  // => \"/path/to/project/node_modules/zod/index.ts\"\n\n  import.meta.resolveSync(\"./file.tsx\");\n  // => \"/path/to/project/file.tsx\"\n  ```\n\n{% /table %}\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/node Api instructions from the following content:"}, {"role": "assistant", "content": "Node-API is an interface for building native add-ons to Node.js. Bun implements 95% of this interface from scratch, so most existing Node-API extensions will work with Bun out of the box. Track the completion status of it in [this issue](https://github.com/oven-sh/bun/issues/158).\n\nAs in Node.js, `.node` files (Node-API modules) can be required directly in Bun.\n\n```js\nconst napi = require(\"./my-node-module.node\");\n```\n\nAlternatively, use `process.dlopen`:\n\n```js\nlet mod = { exports: {} };\nprocess.dlopen(mod, \"./my-node-module.node\");\n```\n\nBun polyfills the [`detect-libc`](https://npmjs.com/package/detect-libc) package, which is used by many Node-API modules to detect which `.node` binding to `require`.\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/spawn instructions from the following content:"}, {"role": "assistant", "content": "Spawn child processes with `Bun.spawn` or `Bun.spawnSync`.\n\n## Spawn a process (`Bun.spawn()`)\n\nProvide a command as an array of strings. The result of `Bun.spawn()` is a `Bun.Subprocess` object.\n\n```ts\nBun.spawn([\"echo\", \"hello\"]);\n```\n\nThe second argument to `Bun.spawn` is a parameters object that can be used to configure the subprocess.\n\n```ts\nconst proc = Bun.spawn([\"echo\", \"hello\"], {\n  cwd: \"./path/to/subdir\", // specify a working directory\n  env: { ...process.env, FOO: \"bar\" }, // specify environment variables\n  onExit(proc, exitCode, signalCode, error) {\n    // exit handler\n  },\n});\n\nproc.pid; // process ID of subprocess\n```\n\n## Input stream\n\nBy default, the input stream of the subprocess is undefined; it can be configured with the `stdin` parameter.\n\n```ts\nconst proc = Bun.spawn([\"cat\"], {\n  stdin: await fetch(\"https://raw.githubusercontent.com/oven-sh/bun/main/examples/hashing.js\"),\n});\n\nconst text = await new Response(proc.stdout).text();\nconsole.log(text); // \"const input = \"hello world\".repeat(400); ...\"\n```\n\n{% table %}\n\n---\n\n- `null`\n- **Default.** Provide no input to the subprocess\n\n---\n\n- `\"pipe\"`\n- Return a `FileSink` for fast incremental writing\n\n---\n\n- `\"inherit\"`\n- Inherit the `stdin` of the parent process\n\n---\n\n- `Bun.file()`\n- Read from the specified file.\n\n---\n\n- `TypedArray | DataView`\n- Use a binary buffer as input.\n\n---\n\n- `Response`\n- Use the response `body` as input.\n\n---\n\n- `Request`\n- Use the request `body` as input.\n\n---\n\n- `number`\n- Read from the file with a given file descriptor.\n\n{% /table %}\n\nThe `\"pipe\"` option lets incrementally write to the subprocess's input stream from the parent process.\n\n```ts\nconst proc = Bun.spawn([\"cat\"], {\n  stdin: \"pipe\", // return a FileSink for writing\n});\n\n// enqueue string data\nproc.stdin.write(\"hello\");\n\n// enqueue binary data\nconst enc = new TextEncoder();\nproc.stdin.write(enc.encode(\" world!\"));\n\n// send buffered data\nproc.stdin.flush();\n\n// close the input stream\nproc.stdin.end();\n```\n\n## Output streams\n\nYou can read results from the subprocess via the `stdout` and `stderr` properties. By default these are instances of `ReadableStream`.\n\n```ts\nconst proc = Bun.spawn([\"echo\", \"hello\"]);\nconst text = await new Response(proc.stdout).text();\nconsole.log(text); // => \"hello\"\n```\n\nConfigure the output stream by passing one of the following values to `stdout/stderr`:\n\n{% table %}\n\n---\n\n- `\"pipe\"`\n- **Default for `stdout`.** Pipe the output to a `ReadableStream` on the returned `Subprocess` object.\n\n---\n\n- `\"inherit\"`\n- **Default for `stderr`.** Inherit from the parent process.\n\n---\n\n- `Bun.file()`\n- Write to the specified file.\n\n---\n\n- `null`\n- Write to `/dev/null`.\n\n---\n\n- `number`\n- Write to the file with the given file descriptor.\n\n{% /table %}\n\n## Exit handling\n\nUse the `onExit` callback to listen for the process exiting or being killed.\n\n```ts\nconst proc = Bun.spawn([\"echo\", \"hello\"], {\n  onExit(proc, exitCode, signalCode, error) {\n    // exit handler\n  },\n});\n```\n\nFor convenience, the `exited` property is a `Promise` that resolves when the process exits.\n\n```ts\nconst proc = Bun.spawn([\"echo\", \"hello\"]);\n\nawait proc.exited; // resolves when process exit\nproc.killed; // boolean \u2014 was the process killed?\nproc.exitCode; // null | number\nproc.signalCode; // null | \"SIGABRT\" | \"SIGALRM\" | ...\n```\n\nTo kill a process:\n\n```ts\nconst proc = Bun.spawn([\"echo\", \"hello\"]);\nproc.kill();\nproc.killed; // true\n\nproc.kill(); // specify an exit code\n```\n\nThe parent `bun` process will not terminate until all child processes have exited. Use `proc.unref()` to detach the child process from the parent.\n\n```\nconst proc = Bun.spawn([\"echo\", \"hello\"]);\nproc.unref();\n```\n\n## Blocking API (`Bun.spawnSync()`)\n\nBun provides a synchronous equivalent of `Bun.spawn` called `Bun.spawnSync`. This is a blocking API that supports the same inputs and parameters as `Bun.spawn`. It returns a `SyncSubprocess` object, which differs from `Subprocess` in a few ways.\n\n1. It contains a `success` property that indicates whether the process exited with a zero exit code.\n2. The `stdout` and `stderr` properties are instances of `Buffer` instead of `ReadableStream`.\n3. There is no `stdin` property. Use `Bun.spawn` to incrementally write to the subprocess's input stream.\n\n```ts\nconst proc = Bun.spawnSync([\"echo\", \"hello\"]);\n\nconsole.log(proc.stdout.toString());\n// => \"hello\\n\"\n```\n\nAs a rule of thumb, the asynchronous `Bun.spawn` API is better for HTTP servers and apps, and `Bun.spawnSync` is better for building command-line tools.\n\n## Benchmarks\n\n{%callout%}\n\u26a1\ufe0f Under the hood, `Bun.spawn` and `Bun.spawnSync` use [`posix_spawn(3)`](https://man7.org/linux/man-pages/man3/posix_spawn.3.html).\n{%/callout%}\n\nBun's `spawnSync` spawns processes 60% faster than the Node.js `child_process` module.\n\n```bash\n$ bun spawn.mjs\ncpu: Apple M1 Max\nruntime: bun 0.2.0 (arm64-darwin)\n\nbenchmark              time (avg)             (min \u2026 max)       p75       p99      p995\n--------------------------------------------------------- -----------------------------\nspawnSync echo hi  888.14 \u00b5s/iter    (821.83 \u00b5s \u2026 1.2 ms) 905.92 \u00b5s      1 ms   1.03 ms\n$ node spawn.node.mjs\ncpu: Apple M1 Max\nruntime: node v18.9.1 (arm64-darwin)\n\nbenchmark              time (avg)             (min \u2026 max)       p75       p99      p995\n--------------------------------------------------------- -----------------------------\nspawnSync echo hi    1.47 ms/iter     (1.14 ms \u2026 2.64 ms)   1.57 ms   2.37 ms   2.52 ms\n```\n\n## Reference\n\nA simple reference of the Spawn API and types are shown below. The real types have complex generics to strongly type the `Subprocess` streams with the options passed to `Bun.spawn` and `Bun.spawnSync`. For full details, find these types as defined [bun.d.ts](https://github.com/oven-sh/bun/blob/main/packages/bun-types/bun.d.ts).\n\n```ts\ninterface Bun {\n  spawn(command: string[], options?: SpawnOptions.OptionsObject): Subprocess;\n  spawnSync(command: string[], options?: SpawnOptions.OptionsObject): SyncSubprocess;\n\n  spawn(options: { cmd: string[] } & SpawnOptions.OptionsObject): Subprocess;\n  spawnSync(options: { cmd: string[] } & SpawnOptions.OptionsObject): SyncSubprocess;\n}\n\nnamespace SpawnOptions {\n  interface OptionsObject {\n    cwd?: string;\n    env?: Record<string, string>;\n    stdin?: SpawnOptions.Readable;\n    stdout?: SpawnOptions.Writable;\n    stderr?: SpawnOptions.Writable;\n    onExit?: (proc: Subprocess, exitCode: number | null, signalCode: string | null, error: Error | null) => void;\n  }\n\n  type Readable =\n    | \"pipe\"\n    | \"inherit\"\n    | \"ignore\"\n    | null // equivalent to \"ignore\"\n    | undefined // to use default\n    | BunFile\n    | ArrayBufferView\n    | number;\n\n  type Writable =\n    | \"pipe\"\n    | \"inherit\"\n    | \"ignore\"\n    | null // equivalent to \"ignore\"\n    | undefined // to use default\n    | BunFile\n    | ArrayBufferView\n    | number\n    | ReadableStream\n    | Blob\n    | Response\n    | Request;\n}\n\ninterface Subprocess<Stdin, Stdout, Stderr> {\n  readonly pid: number;\n  // the exact stream types here are derived from the generic parameters\n  readonly stdin: number | ReadableStream | FileSink | undefined;\n  readonly stdout: number | ReadableStream | undefined;\n  readonly stderr: number | ReadableStream | undefined;\n\n  readonly exited: Promise<number>;\n\n  readonly exitCode: number | undefined;\n  readonly signalCode: Signal | null;\n  readonly killed: boolean;\n\n  ref(): void;\n  unref(): void;\n  kill(code?: number): void;\n}\n\ninterface SyncSubprocess<Stdout, Stderr> {\n  readonly pid: number;\n  readonly success: boolean;\n  // the exact buffer types here are derived from the generic parameters\n  readonly stdout: Buffer | undefined;\n  readonly stderr: Buffer | undefined;\n}\n\ntype ReadableSubprocess = Subprocess<any, \"pipe\", \"pipe\">;\ntype WritableSubprocess = Subprocess<\"pipe\", any, any>;\ntype PipedSubprocess = Subprocess<\"pipe\", \"pipe\", \"pipe\">;\ntype NullSubprocess = Subprocess<null, null, null>;\n\ntype ReadableSyncSubprocess = SyncSubprocess<\"pipe\", \"pipe\">;\ntype NullSyncSubprocess = SyncSubprocess<null, null>;\n\ntype Signal =\n  | \"SIGABRT\"\n  | \"SIGALRM\"\n  | \"SIGBUS\"\n  | \"SIGCHLD\"\n  | \"SIGCONT\"\n  | \"SIGFPE\"\n  | \"SIGHUP\"\n  | \"SIGILL\"\n  | \"SIGINT\"\n  | \"SIGIO\"\n  | \"SIGIOT\"\n  | \"SIGKILL\"\n  | \"SIGPIPE\"\n  | \"SIGPOLL\"\n  | \"SIGPROF\"\n  | \"SIGPWR\"\n  | \"SIGQUIT\"\n  | \"SIGSEGV\"\n  | \"SIGSTKFLT\"\n  | \"SIGSTOP\"\n  | \"SIGSYS\"\n  | \"SIGTERM\"\n  | \"SIGTRAP\"\n  | \"SIGTSTP\"\n  | \"SIGTTIN\"\n  | \"SIGTTOU\"\n  | \"SIGUNUSED\"\n  | \"SIGURG\"\n  | \"SIGUSR1\"\n  | \"SIGUSR2\"\n  | \"SIGVTALRM\"\n  | \"SIGWINCH\"\n  | \"SIGXCPU\"\n  | \"SIGXFSZ\"\n  | \"SIGBREAK\"\n  | \"SIGLOST\"\n  | \"SIGINFO\";\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/sqlite instructions from the following content:"}, {"role": "assistant", "content": "Bun natively implements a high-performance [SQLite3](https://www.sqlite.org/) driver. To use it import from the built-in `bun:sqlite` module.\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\nconst db = new Database(\":memory:\");\nconst query = db.query(\"select 'Hello world' as message;\");\nquery.get(); // => { message: \"Hello world\" }\n```\n\nThe API is simple, synchronous, and fast. Credit to [better-sqlite3](https://github.com/JoshuaWise/better-sqlite3) and its contributors for inspiring the API of `bun:sqlite`.\n\nFeatures include:\n\n- Transactions\n- Parameters (named & positional)\n- Prepared statements\n- Datatype conversions (`BLOB` becomes `Uint8Array`)\n- The fastest performance of any SQLite driver for JavaScript\n\nThe `bun:sqlite` module is roughly 3-6x faster than `better-sqlite3` and 8-9x faster than `deno.land/x/sqlite` for read queries. Each driver was benchmarked against the [Northwind Traders](https://github.com/jpwhite3/northwind-SQLite3/blob/46d5f8a64f396f87cd374d1600dbf521523980e8/Northwind_large.sqlite.zip) dataset. View and run the [benchmark source](https://github.com/oven-sh/bun/tree/main/bench/sqlite).\n\n{% image width=\"738\" alt=\"SQLite benchmarks for Bun, better-sqlite3, and deno.land/x/sqlite\" src=\"https://user-images.githubusercontent.com/709451/168459263-8cd51ca3-a924-41e9-908d-cf3478a3b7f3.png\" caption=\"Benchmarked on an M1 MacBook Pro (64GB) running macOS 12.3.1\" /%}\n\n## Database\n\nTo open or create a SQLite3 database:\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\nconst db = new Database(\"mydb.sqlite\");\n```\n\nTo open an in-memory database:\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\n// all of these do the same thing\nconst db = new Database(\":memory:\");\nconst db = new Database();\nconst db = new Database(\"\");\n```\n\nTo open in `readonly` mode:\n\n```ts\nimport { Database } from \"bun:sqlite\";\nconst db = new Database(\"mydb.sqlite\", { readonly: true });\n```\n\nTo create the database if the file doesn't exist:\n\n```ts\nimport { Database } from \"bun:sqlite\";\nconst db = new Database(\"mydb.sqlite\", { create: true });\n```\n\n### `.close()`\n\nTo close a database:\n\n```ts\nconst db = new Database();\ndb.close();\n```\n\nNote: `close()` is called automatically when the database is garbage collected. It is safe to call multiple times but has no effect after the first.\n\n### `.serialize()`\n\n`bun:sqlite` supports SQLite's built-in mechanism for [serializing](https://www.sqlite.org/c3ref/serialize.html) and [deserializing](https://www.sqlite.org/c3ref/deserialize.html) databases to and from memory.\n\n```ts\nconst olddb = new Database(\"mydb.sqlite\");\nconst contents = olddb.serialize(); // => Uint8Array\nconst newdb = Database.deserialize(contents);\n```\n\nInternally, `.serialize()` calls [`sqlite3_serialize`](https://www.sqlite.org/c3ref/serialize.html).\n\n### `.query()`\n\nUse the `db.query()` method on your `Database` instance to [prepare](https://www.sqlite.org/c3ref/prepare.html) a SQL query. The result is a `Statement` instance that will be cached on the `Database` instance. _The query will not be executed._\n\n```ts\nconst query = db.query(`select \"Hello world\" as message`);\n```\n\n{% callout %}\n\n**Note** \u2014 Use the `.prepare()` method to prepare a query _without_ caching it on the `Database` instance.\n\n```ts\n// compile the prepared statement\nconst query = db.prepare(\"SELECT * FROM foo WHERE bar = ?\");\n```\n\n{% /callout %}\n\n## Statements\n\nA `Statement` is a _prepared query_, which means it's been parsed and compiled into an efficient binary form. It can be executed multiple times in a performant way.\n\nCreate a statement with the `.query` method on your `Database` instance.\n\n```ts\nconst query = db.query(`select \"Hello world\" as message`);\n```\n\nQueries can contain parameters. These can be numerical (`?1`) or named (`$param` or `:param` or `@param`).\n\n```ts\nconst query = db.query(`SELECT ?1, ?2;`);\nconst query = db.query(`SELECT $param1, $param2;`);\n```\n\nValues are bound to these parameters when the query is executed. A `Statement` can be executed with several different methods, each returning the results in a different form.\n\n### `.all()`\n\nUse `.all()` to run a query and get back the results as an array of objects.\n\n```ts\nconst query = db.query(`select $message;`);\nquery.all({ $message: \"Hello world\" });\n// => [{ message: \"Hello world\" }]\n```\n\nInternally, this calls [`sqlite3_reset`](https://www.sqlite.org/capi3ref.html#sqlite3_reset) and repeatedly calls [`sqlite3_step`](https://www.sqlite.org/capi3ref.html#sqlite3_step) until it returns `SQLITE_DONE`.\n\n### `.get()`\n\nUse `.get()` to run a query and get back the first result as an object.\n\n```ts\nconst query = db.query(`select $message;`);\nquery.get({ $message: \"Hello world\" });\n// => { $message: \"Hello world\" }\n```\n\nInternally, this calls [`sqlite3_reset`](https://www.sqlite.org/capi3ref.html#sqlite3_reset) followed by [`sqlite3_step`](https://www.sqlite.org/capi3ref.html#sqlite3_step) until it no longer returns `SQLITE_ROW`. If the query returns no rows, `undefined` is returned.\n\n### `.run()`\n\nUse `.run()` to run a query and get back `undefined`. This is useful for queries schema-modifying queries (e.g. `CREATE TABLE`) or bulk write operations.\n\n```ts\nconst query = db.query(`create table foo;`);\nquery.run();\n// => undefined\n```\n\nInternally, this calls [`sqlite3_reset`](https://www.sqlite.org/capi3ref.html#sqlite3_reset) and calls [`sqlite3_step`](https://www.sqlite.org/capi3ref.html#sqlite3_step) once. Stepping through all the rows is not necessary when you don't care about the results.\n\n### `.values()`\n\nUse `values()` to run a query and get back all results as an array of arrays.\n\n```ts\nconst query = db.query(`select $message;`);\nquery.values({ $message: \"Hello world\" });\n\nquery.values(2);\n// [\n//   [ \"Iron Man\", 2008 ],\n//   [ \"The Avengers\", 2012 ],\n//   [ \"Ant-Man: Quantumania\", 2023 ],\n// ]\n```\n\nInternally, this calls [`sqlite3_reset`](https://www.sqlite.org/capi3ref.html#sqlite3_reset) and repeatedly calls [`sqlite3_step`](https://www.sqlite.org/capi3ref.html#sqlite3_step) until it returns `SQLITE_DONE`.\n\n### `.finalize()`\n\nUse `.finalize()` to destroy a `Statement` and free any resources associated with it. Once finalized, a `Statement` cannot be executed again. Typically, the garbage collector will do this for you, but explicit finalization may be useful in performance-sensitive applications.\n\n```ts\nconst query = db.query(\"SELECT title, year FROM movies\");\nconst movies = query.all();\nquery.finalize();\n```\n\n### `.toString()`\n\nCalling `toString()` on a `Statement` instance prints the expanded SQL query. This is useful for debugging.\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\n// setup\nconst query = db.query(\"SELECT $param;\");\n\nconsole.log(query.toString()); // => \"SELECT NULL\"\n\nquery.run(42);\nconsole.log(query.toString()); // => \"SELECT 42\"\n\nquery.run(365);\nconsole.log(query.toString()); // => \"SELECT 365\"\n```\n\nInternally, this calls [`sqlite3_expanded_sql`](https://www.sqlite.org/capi3ref.html#sqlite3_expanded_sql). The parameters are expanded using the most recently bound values.\n\n## Parameters\n\nQueries can contain parameters. These can be numerical (`?1`) or named (`$param` or `:param` or `@param`). Bind values to these parameters when executing the query:\n\n{% codetabs %}\n\n```ts#Query\nconst query = db.query(\"SELECT * FROM foo WHERE bar = $bar\");\nconst results = query.all({\n  $bar: \"bar\",\n});\n```\n\n```json#Results\n[\n  { \"$bar\": \"bar\" }\n]\n```\n\n{% /codetabs %}\n\nNumbered (positional) parameters work too:\n\n{% codetabs %}\n\n```ts#Query\nconst query = db.query(\"SELECT ?1, ?2\");\nconst results = query.all(\"hello\", \"goodbye\");\n```\n\n```ts#Results\n[\n  {\n    \"?1\": \"hello\",\n    \"?2\": \"goodbye\"\n  }\n]\n```\n\n{% /codetabs %}\n\n## Transactions\n\nTransactions are a mechanism for executing multiple queries in an _atomic_ way; that is, either all of the queries succeed or none of them do. Create a transaction with the `db.transaction()` method:\n\n```ts\nconst insertCat = db.prepare(\"INSERT INTO cats (name) VALUES ($name)\");\nconst insertCats = db.transaction(cats => {\n  for (const cat of cats) insertCat.run(cat);\n});\n```\n\nAt this stage, we haven't inserted any cats! The call to `db.transaction()` returns a new function (`insertCats`) that _wraps_ the function that executes the queries.\n\nTo execute the transaction, call this function. All arguments will be passed through to the wrapped function; the return value of the wrapped function will be returned by the transaction function. The wrapped function also has access to the `this` context as defined where the transaction is executed.\n\n```ts\nconst insert = db.prepare(\"INSERT INTO cats (name) VALUES ($name)\");\nconst insertCats = db.transaction(cats => {\n  for (const cat of cats) insert.run(cat);\n  return cats.length;\n});\n\nconst count = insertCats([\n  { $name: \"Keanu\" },\n  { $name: \"Salem\" },\n  { $name: \"Crookshanks\" },\n]);\n\nconsole.log(`Inserted ${count} cats`);\n```\n\nThe driver will automatically [`begin`](https://www.sqlite.org/lang_transaction.html) a transaction when `insertCats` is called and `commit` it when the wrapped function returns. If an exception is thrown, the transaction will be rolled back. The exception will propagate as usual; it is not caught.\n\n{% callout %}\n**Nested transactions** \u2014 Transaction functions can be called from inside other transaction functions. When doing so, the inner transaction becomes a [savepoint](https://www.sqlite.org/lang_savepoint.html).\n\n{% details summary=\"View nested transaction example\" %}\n\n```ts\n// setup\nimport { Database } from \"bun:sqlite\";\nconst db = Database.open(\":memory:\");\ndb.run(\n  \"CREATE TABLE expenses (id INTEGER PRIMARY KEY AUTOINCREMENT, note TEXT, dollars INTEGER);\",\n);\ndb.run(\n  \"CREATE TABLE cats (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, age INTEGER)\",\n);\nconst insertExpense = db.prepare(\n  \"INSERT INTO expenses (note, dollars) VALUES (?, ?)\",\n);\nconst insert = db.prepare(\"INSERT INTO cats (name, age) VALUES ($name, $age)\");\nconst insertCats = db.transaction(cats => {\n  for (const cat of cats) insert.run(cat);\n});\n\nconst adopt = db.transaction(cats => {\n  insertExpense.run(\"adoption fees\", 20);\n  insertCats(cats); // nested transaction\n});\n\nadopt([\n  { $name: \"Joey\", $age: 2 },\n  { $name: \"Sally\", $age: 4 },\n  { $name: \"Junior\", $age: 1 },\n]);\n```\n\n{% /details %}\n{% /callout %}\n\nTransactions also come with `deferred`, `immediate`, and `exclusive` versions.\n\n```ts\ninsertCats(cats); // uses \"BEGIN\"\ninsertCats.deferred(cats); // uses \"BEGIN DEFERRED\"\ninsertCats.immediate(cats); // uses \"BEGIN IMMEDIATE\"\ninsertCats.exclusive(cats); // uses \"BEGIN EXCLUSIVE\"\n```\n\n### `.loadExtension()`\n\nTo load a [SQLite extension](https://www.sqlite.org/loadext.html), call `.loadExtension(name)` on your `Database` instance\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\nconst db = new Database();\ndb.loadExtension(\"myext\");\n```\n\n{% details summary=\"For macOS users\" %}\n**MacOS users** By default, macOS ships with Apple's proprietary build of SQLite, which doesn't support extensions. To use extensions, you'll need to install a vanilla build of SQLite.\n\n```bash\n$ brew install sqlite\n$ which sqlite # get path to binary\n```\n\nTo point `bun:sqlite` to the new build, call `Database.setCustomSQLite(path)` before creating any `Database` instances. (On other operating systems, this is a no-op.) Pass a path to the SQLite `.dylib` file, _not_ the executable. With recent versions of Homebrew this is something like `/opt/homebrew/Cellar/sqlite/<version>/libsqlite3.dylib`.\n\n```ts\nimport { Database } from \"bun:sqlite\";\n\nDatabase.setCustomSQLite(\"/path/to/libsqlite.dylib\");\n\nconst db = new Database();\ndb.loadExtension(\"myext\");\n```\n\n{% /details %}\n\n## Reference\n\n```ts\nclass Database {\n  constructor(\n    filename: string,\n    options?:\n      | number\n      | {\n          readonly?: boolean;\n          create?: boolean;\n          readwrite?: boolean;\n        },\n  );\n\n  query<Params, ReturnType>(sql: string): Statement<Params, ReturnType>;\n}\n\nclass Statement<Params, ReturnType> {\n  all(params: Params): ReturnType[];\n  get(params: Params): ReturnType | undefined;\n  run(params: Params): void;\n  values(params: Params): unknown[][];\n\n  finalize(): void; // destroy statement and clean up resources\n  toString(): string; // serialize to SQL\n\n  columnNames: string[]; // the column names of the result set\n  paramsCount: number; // the number of parameters expected by the statement\n  native: any; // the native object representing the statement\n}\n\ntype SQLQueryBindings =\n  | string\n  | bigint\n  | TypedArray\n  | number\n  | boolean\n  | null\n  | Record<string, string | bigint | TypedArray | number | boolean | null>;\n```\n\n### Datatypes\n\n| JavaScript type | SQLite type            |\n| --------------- | ---------------------- |\n| `string`        | `TEXT`                 |\n| `number`        | `INTEGER` or `DECIMAL` |\n| `boolean`       | `INTEGER` (1 or 0)     |\n| `Uint8Array`    | `BLOB`                 |\n| `Buffer`        | `BLOB`                 |\n| `bigint`        | `INTEGER`              |\n| `null`          | `NULL`                 |\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/streams instructions from the following content:"}, {"role": "assistant", "content": "Streams are an important abstraction for working with binary data without loading it all into memory at once. They are commonly used for reading and writing files, sending and receiving network requests, and processing large amounts of data.\n\nBun implements the Web APIs [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) and [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).\n\n{% callout %}\nBun also implements the `node:stream` module, including [`Readable`](https://nodejs.org/api/stream.html#stream_readable_streams), [`Writable`](https://nodejs.org/api/stream.html#stream_writable_streams), and [`Duplex`](https://nodejs.org/api/stream.html#stream_duplex_and_transform_streams). For complete documentation, refer to the [Node.js docs](https://nodejs.org/api/stream.html).\n{% /callout %}\n\nTo create a simple `ReadableStream`:\n\n```ts\nconst stream = new ReadableStream({\n  start(controller) {\n    controller.enqueue(\"hello\");\n    controller.enqueue(\"world\");\n    controller.close();\n  },\n});\n```\n\nThe contents of a `ReadableStream` can be read chunk-by-chunk with `for await` syntax.\n\n```ts\nfor await (const chunk of stream) {\n  console.log(chunk);\n  // => \"hello\"\n  // => \"world\"\n}\n```\n\n## Direct `ReadableStream`\n\nBun implements an optimized version of `ReadableStream` that avoid unnecessary data copying & queue management logic. With a traditional `ReadableStream`, chunks of data are _enqueued_. Each chunk is copied into a queue, where it sits until the stream is ready to send more data.\n\n```ts\nconst stream = new ReadableStream({\n  start(controller) {\n    controller.enqueue(\"hello\");\n    controller.enqueue(\"world\");\n    controller.close();\n  },\n});\n```\n\nWith a direct `ReadableStream`, chunks of data are written directly to the stream. No queueing happens, and there's no need to clone the chunk data into memory. The `controller` API is updated to reflect this; instead of `.enqueue()` you call `.write`.\n\n```ts\nconst stream = new ReadableStream({\n  type: \"direct\",\n  pull(controller) {\n    controller.write(\"hello\");\n    controller.write(\"world\");\n  },\n});\n```\n\nWhen using a direct `ReadableStream`, all chunk queueing is handled by the destination. The consumer of the stream receives exactly what is passed to `controller.write()`, without any encoding or modification.\n\n## `Bun.ArrayBufferSink`\n\nThe `Bun.ArrayBufferSink` class is a fast incremental writer for constructing an `ArrayBuffer` of unknown size.\n\n```ts\nconst sink = new Bun.ArrayBufferSink();\n\nsink.write(\"h\");\nsink.write(\"e\");\nsink.write(\"l\");\nsink.write(\"l\");\nsink.write(\"o\");\n\nsink.end();\n// ArrayBuffer(5) [ 104, 101, 108, 108, 111 ]\n```\n\nTo instead retrieve the data as a `Uint8Array`, pass the `asUint8Array` option to the constructor.\n\n```ts-diff\nconst sink = new Bun.ArrayBufferSink({\n+ asUint8Array: true\n});\n\nsink.write(\"h\");\nsink.write(\"e\");\nsink.write(\"l\");\nsink.write(\"l\");\nsink.write(\"o\");\n\nsink.end();\n// Uint8Array(5) [ 104, 101, 108, 108, 111 ]\n```\n\nThe `.write()` method supports strings, typed arrays, `ArrayBuffer`, and `SharedArrayBuffer`.\n\n```ts\nsink.write(\"h\");\nsink.write(new Uint8Array([101, 108]));\nsink.write(Buffer.from(\"lo\").buffer);\n\nsink.end();\n```\n\nOnce `.end()` is called, no more data can be written to the `ArrayBufferSink`. However, in the context of buffering a stream, it's useful to continuously write data and periodically `.flush()` the contents (say, into a `WriteableStream`). To support this, pass `stream: true` to the constructor.\n\n```ts\nconst sink = new Bun.ArrayBufferSink({\n  stream: true,\n});\n\nsink.write(\"h\");\nsink.write(\"e\");\nsink.write(\"l\");\nsink.flush();\n// ArrayBuffer(5) [ 104, 101, 108 ]\n\nsink.write(\"l\");\nsink.write(\"o\");\nsink.flush();\n// ArrayBuffer(5) [ 108, 111 ]\n```\n\nThe `.flush()` method returns the buffered data as an `ArrayBuffer` (or `Uint8Array` if `asUint8Array: true`) and clears internal buffer.\n\nTo manually set the size of the internal buffer in bytes, pass a value for `highWaterMark`:\n\n```ts\nconst sink = new Bun.ArrayBufferSink({\n  highWaterMark: 1024 * 1024, // 1 MB\n});\n```\n\n{% details summary=\"Reference\" %}\n\n```ts\n/**\n * Fast incremental writer that becomes an `ArrayBuffer` on end().\n */\nexport class ArrayBufferSink {\n  constructor();\n\n  start(options?: {\n    asUint8Array?: boolean;\n    /**\n     * Preallocate an internal buffer of this size\n     * This can significantly improve performance when the chunk size is small\n     */\n    highWaterMark?: number;\n    /**\n     * On {@link ArrayBufferSink.flush}, return the written data as a `Uint8Array`.\n     * Writes will restart from the beginning of the buffer.\n     */\n    stream?: boolean;\n  }): void;\n\n  write(\n    chunk: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer,\n  ): number;\n  /**\n   * Flush the internal buffer\n   *\n   * If {@link ArrayBufferSink.start} was passed a `stream` option, this will return a `ArrayBuffer`\n   * If {@link ArrayBufferSink.start} was passed a `stream` option and `asUint8Array`, this will return a `Uint8Array`\n   * Otherwise, this will return the number of bytes written since the last flush\n   *\n   * This API might change later to separate Uint8ArraySink and ArrayBufferSink\n   */\n  flush(): number | Uint8Array | ArrayBuffer;\n  end(): ArrayBuffer | Uint8Array;\n}\n```\n\n{% /details %}\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/tcp instructions from the following content:"}, {"role": "assistant", "content": "Use Bun's native TCP API to implement performance sensitive systems like database clients, game servers, or anything that needs to communicate over TCP (instead of HTTP). This is a low-level API intended for library authors and for advanced use cases.\n\n## Start a server (`Bun.listen()`)\n\nTo start a TCP server with `Bun.listen`:\n\n```ts\nBun.listen({\n  hostname: \"localhost\",\n  port: 8080,\n  socket: {\n    data(socket, data) {}, // message received from client\n    open(socket) {}, // socket opened\n    close(socket) {}, // socket closed\n    drain(socket) {}, // socket ready for more data\n    error(socket, error) {}, // error handler\n  },\n});\n```\n\n{% details summary=\"An API designed for speed\" %}\n\nIn Bun, a set of handlers are declared once per server instead of assigning callbacks to each socket, as with Node.js `EventEmitters` or the web-standard `WebSocket` API.\n\n```ts\nBun.listen({\n  hostname: \"localhost\",\n  port: 8080,\n  socket: {\n    open(socket) {},\n    data(socket, data) {},\n    drain(socket) {},\n    close(socket) {},\n    error(socket, error) {},\n  },\n});\n```\n\nFor performance-sensitive servers, assigning listeners to each socket can cause significant garbage collector pressure and increase memory usage. By contrast, Bun only allocates one handler function for each event and shares it among all sockets. This is a small optimization, but it adds up.\n\n{% /details %}\n\nContextual data can be attached to a socket in the `open` handler.\n\n```ts\ntype SocketData = { sessionId: string };\n\nBun.listen<SocketData>({\n  hostname: \"localhost\",\n  port: 8080,\n  socket: {\n    data(socket, data) {\n      socket.write(`${socket.data.sessionId}: ack`);\n    },\n    open(socket) {\n      socket.data = { sessionId: \"abcd\" };\n    },\n  },\n});\n```\n\nTo enable TLS, pass a `tls` object containing `key` and `cert` fields.\n\n```ts\nBun.listen({\n  hostname: \"localhost\",\n  port: 8080,\n  socket: {\n    data(socket, data) {},\n  },\n  tls: {\n    // can be string, BunFile, TypedArray, Buffer, or array thereof\n    key: Bun.file(\"./key.pem\"),\n    cert: Bun.file(\"./cert.pem\"),\n  },\n});\n```\n\n{% callout %}\n\n**Note** \u2014\u00a0Earlier versions of Bun supported passing a file path as `keyFile` and `certFile`; this has been deprecated as of `v0.6.3`.\n\n{% /callout %}\n\nThe `key` and `cert` fields expect the _contents_ of your TLS key and certificate. This can be a string, `BunFile`, `TypedArray`, or `Buffer`.\n\n```ts\nBun.listen({\n  // ...\n  tls: {\n    // BunFile\n    key: Bun.file(\"./key.pem\"),\n    // Buffer\n    key: fs.readFileSync(\"./key.pem\"),\n    // string\n    key: fs.readFileSync(\"./key.pem\", \"utf8\"),\n    // array of above\n    key: [Bun.file('./key1.pem'), Bun.file('./key2.pem')]\n  },\n});\n```\n\nThe result of `Bun.listen` is a server that conforms to the `TCPSocket` interface.\n\n```ts\nconst server = Bun.listen({\n  /* config*/\n});\n\n// stop listening\n// parameter determines whether active connections are closed\nserver.stop(true);\n\n// let Bun process exit even if server is still listening\nserver.unref();\n```\n\n## Create a connection (`Bun.connect()`)\n\nUse `Bun.connect` to connect to a TCP server. Specify the server to connect to with `hostname` and `port`. TCP clients can define the same set of handlers as `Bun.listen`, plus a couple client-specific handlers.\n\n```ts\n// The client\nconst socket = Bun.connect({\n  hostname: \"localhost\",\n  port: 8080,\n\n  socket: {\n    data(socket, data) {},\n    open(socket) {},\n    close(socket) {},\n    drain(socket) {},\n    error(socket, error) {},\n\n    // client-specific handlers\n    connectError(socket, error) {}, // connection failed\n    end(socket) {}, // connection closed by server\n    timeout(socket) {}, // connection timed out\n  },\n});\n```\n\nTo require TLS, specify `tls: true`.\n\n```ts\n// The client\nconst socket = Bun.connect({\n  // ... config\n  tls: true,\n});\n```\n\n## Hot reloading\n\nBoth TCP servers and sockets can be hot reloaded with new handlers.\n\n{% codetabs %}\n\n```ts#Server\nconst server = Bun.listen({ /* config */ })\n\n// reloads handlers for all active server-side sockets\nserver.reload({\n  socket: {\n    data(){\n      // new 'data' handler\n    }\n  }\n})\n```\n\n```ts#Client\nconst socket = Bun.connect({ /* config */ })\nsocket.reload({\n  data(){\n    // new 'data' handler\n  }\n})\n```\n\n{% /codetabs %}\n\n## Buffering\n\nCurrently, TCP sockets in Bun do not buffer data. For performance-sensitive code, it's important to consider buffering carefully. For example, this:\n\n```ts\nsocket.write(\"h\");\nsocket.write(\"e\");\nsocket.write(\"l\");\nsocket.write(\"l\");\nsocket.write(\"o\");\n```\n\n...performs significantly worse than this:\n\n```ts\nsocket.write(\"hello\");\n```\n\nTo simplify this for now, consider using Bun's `ArrayBufferSink` with the `{stream: true}` option:\n\n```ts\nconst sink = new ArrayBufferSink({ stream: true, highWaterMark: 1024 });\n\nsink.write(\"h\");\nsink.write(\"e\");\nsink.write(\"l\");\nsink.write(\"l\");\nsink.write(\"o\");\n\nqueueMicrotask(() => {\n  var data = sink.flush();\n  if (!socket.write(data)) {\n    // put it back in the sink if the socket is full\n    sink.write(data);\n  }\n});\n```\n\n{% callout %}\n**Corking** \u2014 Support for corking is planned, but in the meantime backpressure must be managed manually with the `drain` handler.\n{% /callout %}\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/test instructions from the following content:"}, {"role": "assistant", "content": "See the [`bun test`](/docs/cli/test) documentation.\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/transpiler instructions from the following content:"}, {"role": "assistant", "content": "Bun exposes its internal transpiler via the `Bun.Transpiler` class. To create an instance of Bun's transpiler:\n\n```ts\nconst transpiler = new Bun.Transpiler({\n  loader: \"tsx\", // \"js | \"jsx\" | \"ts\" | \"tsx\"\n});\n```\n\n## `.transformSync()`\n\nTranspile code synchronously with the `.transformSync()` method. Modules are not resolved and the code is not executed. The result is a string of vanilla JavaScript code.\n\n<!-- It is synchronous and runs in the same thread as other JavaScript code. -->\n\n{% codetabs %}\n\n```js#Example\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\n\nconst code = `\nimport * as whatever from \"./whatever.ts\"\nexport function Home(props: {title: string}){\n  return <p>{props.title}</p>;\n}`;\n\nconst result = transpiler.transformSync(code);\n```\n\n```js#Result\nimport { __require as require } from \"bun:wrap\";\nimport * as JSX from \"react/jsx-dev-runtime\";\nvar jsx = require(JSX).jsxDEV;\n\nexport default jsx(\n  \"div\",\n  {\n    children: \"hi!\",\n  },\n  undefined,\n  false,\n  undefined,\n  this,\n);\n```\n\n{% /codetabs %}\n\nTo override the default loader specified in the `new Bun.Transpiler()` constructor, pass a second argument to `.transformSync()`.\n\n```ts\nawait transpiler.transform(\"<div>hi!</div>\", \"tsx\");\n```\n\n{% details summary=\"Nitty gritty\" %}\nWhen `.transformSync` is called, the transpiler is run in the same thread as the currently executed code.\n\nIf a macro is used, it will be run in the same thread as the transpiler, but in a separate event loop from the rest of your application. Currently, globals between macros and regular code are shared, which means it is possible (but not recommended) to share states between macros and regular code. Attempting to use AST nodes outside of a macro is undefined behavior.\n{% /details %}\n\n## `.transform()`\n\nThe `transform()` method is an async version of `.transformSync()` that returns a `Promise<string>`.\n\n```js\nconst transpiler = new Bun.Transpiler({ loader: \"jsx\" });\nconst result = await transpiler.transform(\"<div>hi!</div>\");\nconsole.log(result);\n```\n\nUnless you're transpiling _many_ large files, you should probably use `Bun.Transpiler.transformSync`. The cost of the threadpool will often take longer than actually transpiling code.\n\n```ts\nawait transpiler.transform(\"<div>hi!</div>\", \"tsx\");\n```\n\n{% details summary=\"Nitty gritty\" %}\nThe `.tranform()` method runs the transpiler in Bun's worker threadpool, so if you run it 100 times, it will run it across `Math.floor($cpu_count * 0.8)` threads, without blocking the main JavaScript thread.\n\nIf your code uses a macro, it will potentially spawn a new copy of Bun's JavaScript runtime environment in that new thread.\n{% /details %}\n\n## `.scan()`\n\nThe `Transpiler` instance can also scan some source code and return a list of its imports and exports, plus additional metadata about each one. [Type-only](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) imports and exports are ignored.\n\n{% codetabs %}\n\n```ts#Example\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\n\nconst code = `\nimport React from 'react';\nimport type {ReactNode} from 'react';\nconst val = require('./cjs.js')\nimport('./loader');\n\nexport const name = \"hello\";\n`;\n\nconst result = transpiler.scan(code);\n```\n\n```json#Output\n{\n  \"exports\": [\n    \"name\"\n  ],\n  \"imports\": [\n    {\n      \"kind\": \"import-statement\",\n      \"path\": \"react\"\n    },\n    {\n      \"kind\": \"import-statement\",\n      \"path\": \"remix\"\n    },\n    {\n      \"kind\": \"dynamic-import\",\n      \"path\": \"./loader\"\n    }\n  ]\n}\n```\n\n{% /codetabs %}\n\nEach import in the `imports` array has a `path` and `kind`. Bun categories imports into the following kinds:\n\n- `import-statement`: `import React from 'react'`\n- `require-call`: `const val = require('./cjs.js')`\n- `require-resolve`: `require.resolve('./cjs.js')`\n- `dynamic-import`: `import('./loader')`\n- `import-rule`: `@import 'foo.css'`\n- `url-token`: `url('./foo.png')`\n<!-- - `internal`: `import {foo} from 'bun:internal'`\n- `entry-point`: `import {foo} from 'bun:entry'` -->\n\n## `.scanImports()`\n\nFor performance-sensitive code, you can use the `.scanImports()` method to get a list of imports. It's faster than `.scan()` (especially for large files) but marginally less accurate due to some performance optimizations.\n\n{% codetabs %}\n\n```ts#Example\nconst transpiler = new Bun.Transpiler({\n  loader: 'tsx',\n});\n\nconst code = `\nimport React from 'react';\nimport type {ReactNode} from 'react';\nconst val = require('./cjs.js')\nimport('./loader');\n\nexport const name = \"hello\";\n`;\n\nconst result = transpiler.scanImports(code);\n`);\n```\n\n```json#Results\n[\n  {\n    kind: \"import-statement\",\n    path: \"react\"\n  }, {\n    kind: \"require-call\",\n    path: \"./cjs.js\"\n  }, {\n    kind: \"dynamic-import\",\n    path: \"./loader\"\n  }\n]\n```\n\n{% /codetabs %}\n\n## Reference\n\n```ts\ntype Loader = \"jsx\" | \"js\" | \"ts\" | \"tsx\";\n\ninterface TranspilerOptions {\n  // Replace key with value. Value must be a JSON string.\n  // { \"process.env.NODE_ENV\": \"\\\"production\\\"\" }\n  define?: Record<string, string>,\n\n  // Default loader for this transpiler\n  loader?: Loader,\n\n  // Default platform to target\n  // This affects how import and/or require is used\n  target?: \"browser\" | \"bun\" | \"node\",\n\n  // Specify a tsconfig.json file as stringified JSON or an object\n  // Use this to set a custom JSX factory, fragment, or import source\n  // For example, if you want to use Preact instead of React. Or if you want to use Emotion.\n  tsconfig?: string | TSConfig,\n\n  // Replace imports with macros\n  macro?: MacroMap,\n\n  // Specify a set of exports to eliminate\n  // Or rename certain exports\n  exports?: {\n      eliminate?: string[];\n      replace?: Record<string, string>;\n  },\n\n  // Whether to remove unused imports from transpiled file\n  // Default: false\n  trimUnusedImports?: boolean,\n\n  // Whether to enable a set of JSX optimizations\n  // jsxOptimizationInline ...,\n\n  // Experimental whitespace minification\n  minifyWhitespace?: boolean,\n\n  // Whether to inline constant values\n  // Typically improves performance and decreases bundle size\n  // Default: true\n  inline?: boolean,\n}\n\n// Map import paths to macros\ninterface MacroMap {\n  // {\n  //   \"react-relay\": {\n  //     \"graphql\": \"bun-macro-relay/bun-macro-relay.tsx\"\n  //   }\n  // }\n  [packagePath: string]: {\n    [importItemName: string]: string,\n  },\n}\n\nclass Bun.Transpiler {\n  constructor(options: TranspilerOptions)\n\n  transform(code: string, loader?: Loader): Promise<string>\n  transformSync(code: string, loader?: Loader): string\n\n  scan(code: string): {exports: string[], imports: Import}\n  scanImports(code: string): Import[]\n}\n\ntype Import = {\n  path: string,\n  kind:\n  // import foo from 'bar'; in JavaScript\n  | \"import-statement\"\n  // require(\"foo\") in JavaScript\n  | \"require-call\"\n  // require.resolve(\"foo\") in JavaScript\n  | \"require-resolve\"\n  // Dynamic import() in JavaScript\n  | \"dynamic-import\"\n  // @import() in CSS\n  | \"import-rule\"\n  // url() in CSS\n  | \"url-token\"\n  // The import was injected by Bun\n  | \"internal\"\u00a0\n  // Entry point (not common)\n  | \"entry-point\"\n}\n\nconst transpiler = new Bun.Transpiler({ loader: \"jsx\" });\n```\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/utils instructions from the following content:"}, {"role": "assistant", "content": "## `Bun.version`\n\nA `string` containing the version of the `bun` CLI that is currently running.\n\n```ts\nBun.version;\n// => \"0.6.4\"\n```\n\n## `Bun.revision`\n\nThe git commit of [Bun](https://github.com/oven-sh/bun) that was compiled to create the current `bun` CLI.\n\n```ts\nBun.revision;\n// => \"f02561530fda1ee9396f51c8bc99b38716e38296\"\n```\n\n## `Bun.env`\n\nAn alias for `process.env`.\n\n## `Bun.main`\n\nAn absolute path to the entrypoint of the current program (the file that was executed with `bun run`).\n\n```ts#script.ts\nBun.main;\n// /path/to/script.ts\n```\n\nThis is particular useful for determining whether a script is being directly executed, as opposed to being imported by another script.\n\n```ts\nif (import.meta.path === Bun.main) {\n  // this script is being directly executed\n} else {\n  // this file is being imported from another script\n}\n```\n\nThis is analogous to the [`require.main = module` trick](https://stackoverflow.com/questions/6398196/detect-if-called-through-require-or-directly-by-command-line) in Node.js.\n\n## `Bun.sleep()`\n\n`Bun.sleep(ms: number)` (added in Bun v0.5.6)\n\nReturns a `Promise` that resolves after the given number of milliseconds.\n\n```ts\nconsole.log(\"hello\");\nawait Bun.sleep(1000);\nconsole.log(\"hello one second later!\");\n```\n\nAlternatively, pass a `Date` object to receive a `Promise` that resolves at that point in time.\n\n```ts\nconst oneSecondInFuture = new Date(Date.now() + 1000);\n\nconsole.log(\"hello\");\nawait Bun.sleep(oneSecondInFuture);\nconsole.log(\"hello one second later!\");\n```\n\n## `Bun.sleepSync()`\n\n`Bun.sleepSync(ms: number)` (added in Bun v0.5.6)\n\nA blocking synchronous version of `Bun.sleep`.\n\n```ts\nconsole.log(\"hello\");\nBun.sleepSync(1000); // blocks thread for one second\nconsole.log(\"hello one second later!\");\n```\n\n## `Bun.which()`\n\n`Bun.which(bin: string)`\n\nReturns the path to an executable, similar to typing `which` in your terminal.\n\n```ts\nconst ls = Bun.which(\"ls\");\nconsole.log(ls); // \"/usr/bin/ls\"\n```\n\nBy default Bun looks at the current `PATH` environment variable to determine the path. To configure `PATH`:\n\n```ts\nconst ls = Bun.which(\"ls\", {\n  PATH: \"/usr/local/bin:/usr/bin:/bin\",\n});\nconsole.log(ls); // \"/usr/bin/ls\"\n```\n\nPass a `cwd` option to resolve for executable from within a specific directory.\n\n```ts\nconst ls = Bun.which(\"ls\", {\n  cwd: \"/tmp\",\n  PATH: \"\",\n});\n\nconsole.log(ls); // null\n```\n\n## `Bun.peek()`\n\n`Bun.peek(prom: Promise)` (added in Bun v0.2.2)\n\nReads a promise's result without `await` or `.then`, but only if the promise has already fulfilled or rejected.\n\n```ts\nimport { peek } from \"bun\";\n\nconst promise = Promise.resolve(\"hi\");\n\n// no await!\nconst result = peek(promise);\nconsole.log(result); // \"hi\"\n```\n\nThis is important when attempting to reduce number of extraneous microticks in performance-sensitive code. It's an advanced API and you probably shouldn't use it unless you know what you're doing.\n\n```ts\nimport { peek } from \"bun\";\nimport { expect, test } from \"bun:test\";\n\ntest(\"peek\", () => {\n  const promise = Promise.resolve(true);\n\n  // no await necessary!\n  expect(peek(promise)).toBe(true);\n\n  // if we peek again, it returns the same value\n  const again = peek(promise);\n  expect(again).toBe(true);\n\n  // if we peek a non-promise, it returns the value\n  const value = peek(42);\n  expect(value).toBe(42);\n\n  // if we peek a pending promise, it returns the promise again\n  const pending = new Promise(() => {});\n  expect(peek(pending)).toBe(pending);\n\n  // If we peek a rejected promise, it:\n  // - returns the error\n  // - does not mark the promise as handled\n  const rejected = Promise.reject(\n    new Error(\"Successfully tested promise rejection\"),\n  );\n  expect(peek(rejected).message).toBe(\"Successfully tested promise rejection\");\n});\n```\n\nThe `peek.status` function lets you read the status of a promise without resolving it.\n\n```ts\nimport { peek } from \"bun\";\nimport { expect, test } from \"bun:test\";\n\ntest(\"peek.status\", () => {\n  const promise = Promise.resolve(true);\n  expect(peek.status(promise)).toBe(\"fulfilled\");\n\n  const pending = new Promise(() => {});\n  expect(peek.status(pending)).toBe(\"pending\");\n\n  const rejected = Promise.reject(new Error(\"oh nooo\"));\n  expect(peek.status(rejected)).toBe(\"rejected\");\n});\n```\n\n## `Bun.openInEditor()`\n\nOpens a file in your default editor. Bun auto-detects your editor via the `$VISUAL` or `$EDITOR` environment variables.\n\n```ts\nconst currentFile = import.meta.url;\nBun.openInEditor(currentFile);\n```\n\nYou can override this via the `debug.editor` setting in your [`bunfig.toml`](/docs/runtime/configuration)\n\n```toml-diff#bunfig.toml\n+ [debug]\n+ editor = \"code\"\n```\n\nOr specify an editor with the `editor` param. You can also specify a line and column number.\n\n```ts\nBun.openInEditor(import.meta.url, {\n  editor: \"vscode\", // or \"subl\"\n  line: 10,\n  column: 5,\n});\n```\n\nBun.ArrayBufferSink;\n\n## `Bun.deepEquals()`\n\nNestedly checks if two objects are equivalent. This is used internally by `expect().toEqual()` in `bun:test`.\n\n```ts\nconst foo = { a: 1, b: 2, c: { d: 3 } };\n\n// true\nBun.deepEquals(foo, { a: 1, b: 2, c: { d: 3 } });\n\n// false\nBun.deepEquals(foo, { a: 1, b: 2, c: { d: 4 } });\n```\n\nA third boolean parameter can be used to enable \"strict\" mode. This is used by `expect().toStrictEqual()` in the test runner.\n\n```ts\nconst a = { entries: [1, 2] };\nconst b = { entries: [1, 2], extra: undefined };\n\nBun.deepEquals(a, b); // => true\nBun.deepEquals(a, b, true); // => false\n```\n\nIn strict mode, the following are considered unequal:\n\n```ts\n// undefined values\nBun.deepEquals({}, { a: undefined }, true); // false\n\n// undefined in arrays\nBun.deepEquals([\"asdf\"], [\"asdf\", undefined], true); // false\n\n// sparse arrays\nBun.deepEquals([, 1], [undefined, 1], true); // false\n\n// object literals vs instances w/ same properties\nclass Foo {\n  a = 1;\n}\nBun.deepEquals(new Foo(), { a: 1 }, true); // false\n```\n\n## `Bun.escapeHTML()`\n\n`Bun.escapeHTML(value: string | object | number | boolean): string`\n\nEscapes the following characters from an input string:\n\n- `\"` becomes `\"&quot;\"`\n- `&` becomes `\"&amp;\"`\n- `'` becomes `\"&#x27;\"`\n- `<` becomes `\"&lt;\"`\n- `>` becomes `\"&gt;\"`\n\nThis function is optimized for large input. On an M1X, it processes 480 MB/s -\n20 GB/s, depending on how much data is being escaped and whether there is non-ascii\ntext. Non-string types will be converted to a string before escaping.\n\n<!-- ## `Bun.enableANSIColors()` -->\n\n## `Bun.fileURLToPath()`\n\nConverts a `file://` URL to an absolute path.\n\n```ts\nconst path = Bun.fileURLToPath(new URL(\"file:///foo/bar.txt\"));\nconsole.log(path); // \"/foo/bar.txt\"\n```\n\n## `Bun.pathToFileURL()`\n\nConverts an absolute path to a `file://` URL.\n\n```ts\nconst url = Bun.pathToFileURL(\"/foo/bar.txt\");\nconsole.log(url); // \"file:///foo/bar.txt\"\n```\n\n<!-- Bun.hash; -->\n\n## `Bun.gzipSync()`\n\nCompresses a `Uint8Array` using zlib's GZIP algorithm.\n\n```ts\nconst buf = Buffer.from(\"hello\".repeat(100)); // Buffer extends Uint8Array\nconst compressed = Bun.gzipSync(buf);\n\nbuf; // => Uint8Array(500)\ncompressed; // => Uint8Array(30)\n```\n\nOptionally, pass a parameters object as the second argument:\n\n{% details summary=\"zlib compression options\"%}\n\n```ts\nexport type ZlibCompressionOptions = {\n  /**\n   * The compression level to use. Must be between `-1` and `9`.\n   * - A value of `-1` uses the default compression level (Currently `6`)\n   * - A value of `0` gives no compression\n   * - A value of `1` gives least compression, fastest speed\n   * - A value of `9` gives best compression, slowest speed\n   */\n  level?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n  /**\n   * How much memory should be allocated for the internal compression state.\n   *\n   * A value of `1` uses minimum memory but is slow and reduces compression ratio.\n   *\n   * A value of `9` uses maximum memory for optimal speed. The default is `8`.\n   */\n  memLevel?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n  /**\n   * The base 2 logarithm of the window size (the size of the history buffer).\n   *\n   * Larger values of this parameter result in better compression at the expense of memory usage.\n   *\n   * The following value ranges are supported:\n   * - `9..15`: The output will have a zlib header and footer (Deflate)\n   * - `-9..-15`: The output will **not** have a zlib header or footer (Raw Deflate)\n   * - `25..31` (16+`9..15`): The output will have a gzip header and footer (gzip)\n   *\n   * The gzip header will have no file name, no extra data, no comment, no modification time (set to zero) and no header CRC.\n   */\n  windowBits?:\n    | -9\n    | -10\n    | -11\n    | -12\n    | -13\n    | -14\n    | -15\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31;\n  /**\n   * Tunes the compression algorithm.\n   *\n   * - `Z_DEFAULT_STRATEGY`: For normal data **(Default)**\n   * - `Z_FILTERED`: For data produced by a filter or predictor\n   * - `Z_HUFFMAN_ONLY`: Force Huffman encoding only (no string match)\n   * - `Z_RLE`: Limit match distances to one (run-length encoding)\n   * - `Z_FIXED` prevents the use of dynamic Huffman codes\n   *\n   * `Z_RLE` is designed to be almost as fast as `Z_HUFFMAN_ONLY`, but give better compression for PNG image data.\n   *\n   * `Z_FILTERED` forces more Huffman coding and less string matching, it is\n   * somewhat intermediate between `Z_DEFAULT_STRATEGY` and `Z_HUFFMAN_ONLY`.\n   * Filtered data consists mostly of small values with a somewhat random distribution.\n   */\n  strategy?: number;\n};\n```\n\n{% /details %}\n\n## `Bun.gunzipSync()`\n\nDecompresses a `Uint8Array` using zlib's GUNZIP algorithm.\n\n```ts\nconst buf = Buffer.from(\"hello\".repeat(100)); // Buffer extends Uint8Array\nconst compressed = Bun.gunzipSync(buf);\n\nconst dec = new TextDecoder();\nconst uncompressed = Bun.inflateSync(compressed);\ndec.decode(uncompressed);\n// => \"hellohellohello...\"\n```\n\n## `Bun.deflateSync()`\n\nCompresses a `Uint8Array` using zlib's DEFLATE algorithm.\n\n```ts\nconst buf = Buffer.from(\"hello\".repeat(100));\nconst compressed = Bun.deflateSync(buf);\n\nbuf; // => Uint8Array(25)\ncompressed; // => Uint8Array(10)\n```\n\nThe second argument supports the same set of configuration options as [`Bun.gzipSync`](#bun.gzipSync).\n\n## `Bun.inflateSync()`\n\nDecompresses a `Uint8Array` using zlib's INFLATE algorithm.\n\n```ts\nconst buf = Buffer.from(\"hello\".repeat(100));\nconst compressed = Bun.deflateSync(buf);\n\nconst dec = new TextDecoder();\nconst decompressed = Bun.inflateSync(compressed);\ndec.decode(decompressed);\n// => \"hellohellohello...\"\n```\n\n## `Bun.inspect()`\n\nSerializes an object to a `string` exactly as it would be printed by `console.log`.\n\n```ts\nconst obj = { foo: \"bar\" };\nconst str = Bun.inspect(obj);\n// => '{\\nfoo: \"bar\" \\n}'\n\nconst arr = new Uint8Array([1, 2, 3]);\nconst str = Bun.inspect(arr);\n// => \"Uint8Array(3) [ 1, 2, 3 ]\"\n```\n\n## `Bun.inspect.custom`\n\nThis is the symbol that Bun uses to implement `Bun.inspect`. You can override this to customize how your objects are printed. It is identical to `util.inspect.custom` in Node.js.\n\n```ts\nclass Foo {\n  [Bun.inspect.custom]() {\n    return \"foo\";\n  }\n}\n\nconst foo = new Foo();\nconsole.log(foo); // => \"foo\"\n```\n\n## `Bun.nanoseconds()`\n\nReturns the number of nanoseconds since the current `bun` process started, as a `number`. Useful for high-precision timing and benchmarking.\n\n```ts\nBun.nanoseconds();\n// => 7288958\n```\n\n## `Bun.readableStreamTo*()`\n\nBun implements a set of convenience functions for asynchronously consuming the body of a `ReadableStream` and converting it to various binary formats.\n\n```ts\nconst stream = (await fetch(\"https://bun.sh\")).body;\nstream; // => ReadableStream\n\nawait Bun.readableStreamToArrayBuffer(stream);\n// => ArrayBuffer\n\nawait Bun.readableStreamToBlob(stream);\n// => Blob\n\nawait Bun.readableStreamToJSON(stream);\n// => object\n\nawait Bun.readableStreamToText(stream);\n// => string\n\n// returns all chunks as an array\nawait Bun.readableStreamToArray(stream);\n// => unknown[]\n\n// returns all chunks as a FormData object (encoded as x-www-form-urlencoded)\nawait Bun.readableStreamToFormData(stream);\n\n// returns all chunks as a FormData object (encoded as multipart/form-data)\nawait Bun.readableStreamToFormData(stream, multipartFormBoundary);\n```\n\n## `Bun.resolveSync()`\n\nResolves a file path or module specifier using Bun's internal module resolution algorithm. The first argument is the path to resolve, and the second argument is the \"root\". If no match is found, an `Error` is thrown.\n\n```ts\nBun.resolveSync(\"./foo.ts\", \"/path/to/project\");\n// => \"/path/to/project/foo.ts\"\n\nBun.resolveSync(\"zod\", \"/path/to/project\");\n// => \"/path/to/project/node_modules/zod/index.ts\"\n```\n\nTo resolve relative to the current working directory, pass `process.cwd` or `\".\"` as the root.\n\n```ts\nBun.resolveSync(\"./foo.ts\", process.cwd());\nBun.resolveSync(\"./foo.ts\", \"/path/to/project\");\n```\n\nTo resolve relative to the directory containing the current file, pass `import.meta.dir`.\n\n```ts\nBun.resolveSync(\"./foo.ts\", import.meta.dir);\n```\n\n## `serialize` & `deserialize` in `bun:jsc`\n\nTo save a JavaScript value into an ArrayBuffer & back, use `serialize` and `deserialize` from the `\"bun:jsc\"` module.\n\n```js\nimport { serialize, deserialize } from \"bun:jsc\";\n\nconst buf = serialize({ foo: \"bar\" });\nconst obj = deserialize(buf);\nconsole.log(obj); // => { foo: \"bar\" }\n```\n\nInternally, [`structuredClone`](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) and [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) serialize and deserialize the same way. This exposes the underlying [HTML Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) to JavaScript as an ArrayBuffer.\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/websockets instructions from the following content:"}, {"role": "assistant", "content": "`Bun.serve()` supports server-side WebSockets, with on-the-fly compression, TLS support, and a Bun-native publish-subscribe API.\n\n{% callout %}\n\n**\u26a1\ufe0f 7x more throughput** \u2014 Bun's WebSockets are fast. For a [simple chatroom](https://github.com/oven-sh/bun/tree/main/bench/websocket-server/README.md) on Linux x64, Bun can handle 7x more requests per second than Node.js + [`\"ws\"`](https://github.com/websockets/ws).\n\n| Messages sent per second | Runtime                        | Clients |\n| ------------------------ | ------------------------------ | ------- |\n| ~700,000                 | (`Bun.serve`) Bun v0.2.1 (x64) | 16      |\n| ~100,000                 | (`ws`) Node v18.10.0 (x64)     | 16      |\n\nInternally Bun's WebSocket implementation is built on [uWebSockets](https://github.com/uNetworking/uWebSockets).\n{% /callout %}\n\n## Start a WebSocket server\n\nBelow is a simple WebSocket server built with `Bun.serve`, in which all incoming requests are [upgraded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism) to WebSocket connections in the `fetch` handler. The socket handlers are declared in the `websocket` parameter.\n\n```ts\nBun.serve({\n  fetch(req, server) {\n    // upgrade the request to a WebSocket\n    if (server.upgrade(req)) {\n      return; // do not return a Response\n    }\n    return new Response(\"Upgrade failed :(\", { status: 500 });\n  },\n  websocket: {}, // handlers\n});\n```\n\nThe following WebSocket event handlers are supported:\n\n```ts\nBun.serve({\n  fetch(req, server) {}, // upgrade logic\n  websocket: {\n    message(ws, message) {}, // a message is received\n    open(ws) {}, // a socket is opened\n    close(ws, code, message) {}, // a socket is closed\n    drain(ws) {}, // the socket is ready to receive more data\n  },\n});\n```\n\n{% details summary=\"An API designed for speed\" %}\n\nIn Bun, handlers are declared once per server, instead of per socket.\n\n`ServerWebSocket` expects you to pass a `WebSocketHandler` object to the `Bun.serve()` method which has methods for `open`, `message`, `close`, `drain`, and `error`. This is different than the client-side `WebSocket` class which extends `EventTarget` (onmessage, onopen, onclose),\n\nClients tend to not have many socket connections open so an event-based API makes sense.\n\nBut servers tend to have **many** socket connections open, which means:\n\n- Time spent adding/removing event listeners for each connection adds up\n- Extra memory spent on storing references to callbacks function for each connection\n- Usually, people create new functions for each connection, which also means more memory\n\nSo, instead of using an event-based API, `ServerWebSocket` expects you to pass a single object with methods for each event in `Bun.serve()` and it is reused for each connection.\n\nThis leads to less memory usage and less time spent adding/removing event listeners.\n{% /details %}\n\nThe first argument to each handler is the instance of `ServerWebSocket` handling the event. The `ServerWebSocket` class is a fast, Bun-native implementation of [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) with some additional features.\n\n```ts\nBun.serve({\n  fetch(req, server) {}, // upgrade logic\n  websocket: {\n    message(ws, message) {\n      ws.send(message); // echo back the message\n    },\n  },\n});\n```\n\n### Sending messages\n\nEach `ServerWebSocket` instance has a `.send()` method for sending messages to the client. It supports a range of input types.\n\n```ts\nws.send(\"Hello world\"); // string\nws.send(response.arrayBuffer()); // ArrayBuffer\nws.send(new Uint8Array([1, 2, 3])); // TypedArray | DataView\n```\n\n### Headers\n\nOnce the upgrade succeeds, Bun will send a `101 Switching Protocols` response per the [spec](https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism). Additional `headers` can be attched to this `Response` in the call to `server.upgrade()`.\n\n```ts\nBun.serve({\n  fetch(req, server) {\n    const sessionId = await generateSessionId();\n    server.upgrade(req, {\n      headers: {\n        \"Set-Cookie\": `SessionId=${sessionId}`,\n      },\n    });\n  },\n  websocket: {}, // handlers\n});\n```\n\n### Contextual data\n\nContextual `data` can be attached to a new WebSocket in the `.upgrade()` call. This data is made available on the `ws.data` property inside the WebSocket handlers.\n\n```ts\ntype WebSocketData = {\n  createdAt: number;\n  channelId: string;\n  authToken: string;\n};\n\n// TypeScript: specify the type of `data`\nBun.serve<WebSocketData>({\n  fetch(req, server) {\n    // use a library to parse cookies\n    const cookies = parseCookies(req.headers.get(\"Cookie\"));\n    server.upgrade(req, {\n      // this object must conform to WebSocketData\n      data: {\n        createdAt: Date.now(),\n        channelId: new URL(req.url).searchParams.get(\"channelId\"),\n        authToken: cookies[\"X-Token\"],\n      },\n    });\n\n    return undefined;\n  },\n  websocket: {\n    // handler called when a message is received\n    async message(ws, message) {\n      const user = getUserFromToken(ws.data.authToken);\n\n      await saveMessageToDatabase({\n        channel: ws.data.channelId,\n        message: String(message),\n        userId: user.id,\n      });\n    },\n  },\n});\n```\n\nTo connect to this server from the browser, create a new `WebSocket`.\n\n```ts#browser.js\nconst socket = new WebSocket(\"ws://localhost:3000/chat\");\n\nsocket.addEventListener(\"message\", event => {\n  console.log(event.data);\n})\n```\n\n{% callout %}\n**Identifying users** \u2014\u00a0The cookies that are currently set on the page will be sent with the WebSocket upgrade request and available on `req.headers` in the `fetch` handler. Parse these cookies to determine the identity of the connecting user and set the value of `data` accordingly.\n{% /callout %}\n\n### Pub/Sub\n\nBun's `ServerWebSocket` implementation implements a native publish-subscribe API for topic-based broadcasting. Individual sockets can `.subscribe()` to a topic (specified with a string identifier) and `.publish()` messages to all other subscribers to that topic. This topic-based broadcast API is similar to [MQTT](https://en.wikipedia.org/wiki/MQTT) and [Redis Pub/Sub](https://redis.io/topics/pubsub).\n\n```ts\nconst server = Bun.serve<{ username: string }>({\n  fetch(req, server) {\n    const url = new URL(req.url);\n    if (url.pathname === \"/chat\") {\n      console.log(`upgrade!`);\n      const username = getUsernameFromReq(req);\n      const success = server.upgrade(req, { data: { username } });\n      return success\n        ? undefined\n        : new Response(\"WebSocket upgrade error\", { status: 400 });\n    }\n\n    return new Response(\"Hello world\");\n  },\n  websocket: {\n    open(ws) {\n      const msg = `${ws.data.username} has entered the chat`;\n      ws.subscribe(\"the-group-chat\");\n      ws.publish(\"the-group-chat\", msg);\n    },\n    message(ws, message) {\n      // this is a group chat\n      // so the server re-broadcasts incoming message to everyone\n      ws.publish(\"the-group-chat\", `${ws.data.username}: ${message}`);\n    },\n    close(ws) {\n      const msg = `${ws.data.username} has left the chat`;\n      ws.unsubscribe(\"the-group-chat\");\n      ws.publish(\"the-group-chat\", msg);\n    },\n  },\n});\n\nconsole.log(`Listening on ${server.hostname}:${server.port}`);\n```\n\nCalling `.publish(data)` will send the message to all subscribers of a topic _except_ the socket that called `.publish()`.\n\n### Compression\n\nPer-message [compression](https://websockets.readthedocs.io/en/stable/topics/compression.html) can be enabled with the `perMessageDeflate` parameter.\n\n```ts\nBun.serve({\n  fetch(req, server) {}, // upgrade logic\n  websocket: {\n    // enable compression and decompression\n    perMessageDeflate: true,\n  },\n});\n```\n\nCompression can be enabled for individual messages by passing a `boolean` as the second argument to `.send()`.\n\n```ts\nws.send(\"Hello world\", true);\n```\n\nFor fine-grained control over compression characteristics, refer to the [Reference](#reference).\n\n### Backpressure\n\nThe `.send(message)` method of `ServerWebSocket` returns a `number` indicating the result of the operation.\n\n- `-1` \u2014 The message was enqueued but there is backpressure\n- `0` \u2014 The message was dropped due to a connection issue\n- `1+` \u2014 The number of bytes sent\n\nThis gives you better control over backpressure in your server.\n\n## Connect to a `Websocket` server\n\nTo connect to an external socket server, either from a browser or from Bun, create an instance of `WebSocket` with the constructor.\n\n```ts\nconst socket = new WebSocket(\"ws://localhost:3000\");\n```\n\nIn browsers, the cookies that are currently set on the page will be sent with the WebSocket upgrade request. This is a standard feature of the `WebSocket` API.\n\nFor convenience, Bun lets you setting custom headers directly in the constructor. This is a Bun-specific extension of the `WebSocket` standard. _This will not work in browsers._\n\n```ts\nconst socket = new WebSocket(\"ws://localhost:3000\", {\n  headers: {\n    // custom headers\n  },\n});\n```\n\nTo add event listeners to the socket:\n\n```ts\n// message is received\nsocket.addEventListener(\"message\", event => {});\n\n// socket opened\nsocket.addEventListener(\"open\", event => {});\n\n// socket closed\nsocket.addEventListener(\"close\", event => {});\n\n// error handler\nsocket.addEventListener(\"error\", event => {});\n```\n\n## Reference\n\n```ts\nnamespace Bun {\n  export function serve(params: {\n    fetch: (req: Request, server: Server) => Response | Promise<Response>;\n    websocket?: {\n      message: (\n        ws: ServerWebSocket,\n        message: string | ArrayBuffer | Uint8Array,\n      ) => void;\n      open?: (ws: ServerWebSocket) => void;\n      close?: (ws: ServerWebSocket) => void;\n      error?: (ws: ServerWebSocket, error: Error) => void;\n      drain?: (ws: ServerWebSocket) => void;\n      perMessageDeflate?:\n        | boolean\n        | {\n            compress?: boolean | Compressor;\n            decompress?: boolean | Compressor;\n          };\n    };\n  }): Server;\n}\n\ntype Compressor =\n  | `\"disable\"`\n  | `\"shared\"`\n  | `\"dedicated\"`\n  | `\"3KB\"`\n  | `\"4KB\"`\n  | `\"8KB\"`\n  | `\"16KB\"`\n  | `\"32KB\"`\n  | `\"64KB\"`\n  | `\"128KB\"`\n  | `\"256KB\"`;\n\ninterface Server {\n  pendingWebsockets: number;\n  publish(\n    topic: string,\n    data: string | ArrayBufferView | ArrayBuffer,\n    compress?: boolean,\n  ): number;\n  upgrade(\n    req: Request,\n    options?: {\n      headers?: HeadersInit;\n      data?: any;\n    },\n  ): boolean;\n}\n\ninterface ServerWebSocket {\n  readonly data: any;\n  readonly readyState: number;\n  readonly remoteAddress: string;\n  send(message: string | ArrayBuffer | Uint8Array, compress?: boolean): number;\n  close(code?: number, reason?: string): void;\n  subscribe(topic: string): void;\n  unsubscribe(topic: string): void;\n  publish(topic: string, message: string | ArrayBuffer | Uint8Array): void;\n  isSubscribed(topic: string): boolean;\n  cork(cb: (ws: ServerWebSocket) => void): void;\n}\n```\n\n<!--\n### `Bun.serve(params)`\n\n{% param name=\"params\" %}\nConfiguration object for WebSocket server\n{% /param %}\n\n{% param name=\" fetch\" %}\n`(req: Request, server: Server) => Response | Promise<Response>`\n\nCall `server.upgrade(req)` to upgrade the request to a WebSocket connection. This method returns `true` if the upgrade succeeds, or `false` if the upgrade fails.\n{% /param %}\n\n{% param name=\" websocket\" %}\nConfiguration object for WebSocket server\n{% /param %}\n\n{% param name=\"  message\" %}\n`(ws: ServerWebSocket, message: string | ArrayBuffer | Uint8Array) => void`\n\nThis handler is called when a `WebSocket` receives a message.\n{% /param %}\n\n{% param name=\"  open\" %}\n`(ws: ServerWebSocket) => void`\n\nThis handler is called when a `WebSocket` is opened.\n{% /param %}\n\n{% param name=\"  close\" %}\n`(ws: ServerWebSocket, code: number, message: string) => void`\n\nThis handler is called when a `WebSocket` is closed.\n{% /param %}\n\n{% param name=\"  drain\" %}\n`(ws: ServerWebSocket) => void`\n\nThis handler is called when a `WebSocket` is ready to receive more data.\n{% /param %}\n\n{% param name=\"  perMessageDeflate\" %}\n`boolean | {\\n  compress?: boolean | Compressor;\\n  decompress?: boolean | Compressor \\n}`\n\nEnable per-message compression and decompression. This is a boolean value or an object with `compress` and `decompress` properties. Each property can be a boolean value or one of the following `Compressor` types:\n\n- `\"disable\"`\n- `\"shared\"`\n- `\"dedicated\"`\n- `\"3KB\"`\n- `\"4KB\"`\n- `\"8KB\"`\n- `\"16KB\"`\n- `\"32KB\"`\n- `\"64KB\"`\n- `\"128KB\"`\n- `\"256KB\"`\n\n{% /param %}\n\n### `ServerWebSocket`\n\n{% param name=\"readyState\" %}\n`number`\n\nThe current state of the `WebSocket` connection. This is one of the following values:\n\n- `0` `CONNECTING`\n- `1` `OPEN`\n- `2` `CLOSING`\n- `3` `CLOSED`\n\n{% /param %}\n\n{% param name=\"remoteAddress\" %}\n\n`string`\n\nThe remote address of the `WebSocket` connection\n{% /param %}\n\n{% param name=\"data\" %}\nThe data associated with the `WebSocket` connection. This is set in the `server.upgrade()` call.\n{% /param %}\n\n{% param name=\".send()\" %}\n`send(message: string | ArrayBuffer | Uint8Array, compress?: boolean): number`\n\nSend a message to the client. Returns a `number` indicating the result of the operation.\n\n- `-1`: the message was enqueued but there is backpressure\n- `0`: the message was dropped due to a connection issue\n- `1+`: the number of bytes sent\n\nThe `compress` argument will enable compression for this message, even if the `perMessageDeflate` option is disabled.\n{% /param %}\n\n{% param name=\".subscribe()\" %}\n`subscribe(topic: string): void`\n\nSubscribe to a topic\n{% /param %}\n\n{% param name=\".unsubscribe()\" %}\n`unsubscribe(topic: string): void`\n\nUnsubscribe from a topic\n{% /param %}\n\n{% param name=\".publish()\" %}\n`publish(topic: string, data: string | ArrayBufferView | ArrayBuffer, compress?: boolean): number;`\n\nSend a message to all subscribers of a topic\n{% /param %}\n\n{% param name=\".isSubscribed()\" %}\n`isSubscribed(topic: string): boolean`\n\nCheck if the `WebSocket` is subscribed to a topic\n{% /param %}\n{% param name=\".cork()\" %}\n`cork(cb: (ws: ServerWebSocket) => void): void;`\n\nBatch a set of operations on a `WebSocket` connection. The `message`, `open`, and `drain` callbacks are automatically corked, so\nyou only need to call this if you are sending messages outside of those\ncallbacks or in async functions.\n\n```ts\nws.cork((ws) => {\n  ws.send(\"first\");\n  ws.send(\"second\");\n  ws.send(\"third\");\n});\n```\n\n{% /param %}\n\n{% param name=\".close()\" %}\n`close(code?: number, message?: string): void`\n\nClose the `WebSocket` connection\n{% /param %}\n\n### `Server`\n\n{% param name=\"pendingWebsockets\" %}\nNumber of in-flight `WebSocket` messages\n{% /param %}\n\n{% param name=\".publish()\" %}\n`publish(topic: string, data: string | ArrayBufferView | ArrayBuffer, compress?: boolean): number;`\n\nSend a message to all subscribers of a topic\n{% /param %}\n\n{% param name=\".upgrade()\" %}\n`upgrade(req: Request): boolean`\n\nUpgrade a request to a `WebSocket` connection. Returns `true` if the upgrade succeeds, or `false` if the upgrade fails.\n{% /param %} -->\n"}]}
{"messages": [{"role": "system", "content": "You are a TypeScript Wizard and Bun Expert."}, {"role": "user", "content": "Summarize the Docs/api/workers instructions from the following content:"}, {"role": "assistant", "content": "{% callout %}\n`Worker` support was added in Bun v0.7.0.\n{% /callout %}\n\n[`Worker`](https://developer.mozilla.org/en-US/docs/Web/API/Worker) lets you start and communicate with a new JavaScript instance running on a separate thread while sharing I/O resources with the main thread.\n\nBun implements a minimal version of the [Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) with extensions that make it work better for server-side use cases. Like the rest of Bun, `Worker` in Bun support CommonJS, ES Modules, TypeScript, JSX, TSX and more out of the box. No extra build steps are necessary.\n\n## Creating a `Worker`\n\nLike in browsers, [`Worker`](https://developer.mozilla.org/en-US/docs/Web/API/Worker) is a global. Use it to create a new worker thread.\n\nFrom the main thread:\n\n```js#Main_thread\nconst workerURL = new URL(\"worker.ts\", import.meta.url).href;\nconst worker = new Worker(workerURL);\n\nworker.postMessage(\"hello\");\nworker.onmessage = event => {\n  console.log(event.data);\n};\n```\n\nWorker thread:\n\n```ts#worker.ts_(Worker_thread)\nself.onmessage = (event: MessageEvent) => {\n  console.log(event.data);\n  postMessage(\"world\");\n};\n```\n\nYou can use `import`/`export` syntax in your worker code. Unlike in browsers, there's no need to specify `{type: \"module\"}` to use ES Modules.\n\nTo simplify error handling, the initial script to load is resolved at the time `new Worker(url)` is called.\n\n```js\nconst worker = new Worker(\"/not-found.js\");\n// throws an error immediately\n```\n\nThe specifier passed to `Worker` is resolved relative to the project root (like typing `bun ./path/to/file.js`).\n\n### `\"open\"`\n\nThe `\"open\"` event is emitted when a worker is created and ready to receive messages. This can be used to send an initial message to a worker once it's ready. (This event does not exist in browsers.)\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href);\n\nworker.addEventListener(\"open\", () => {\n  console.log(\"worker is ready\");\n});\n```\n\nMessages are automatically enqueued until the worker is ready, so there is no need to wait for the `\"open\"` event to send messages.\n\n## Messages with `postMessage`\n\nTo send messages, use [`worker.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage) and [`self.postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage). This leverages the [HTML Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n\n```js\n// On the worker thread, `postMessage` is automatically \"routed\" to the parent thread.\npostMessage({ hello: \"world\" });\n\n// On the main thread\nworker.postMessage({ hello: \"world\" });\n```\n\nTo receive messages, use the [`message` event handler](https://developer.mozilla.org/en-US/docs/Web/API/Worker/message_event) on the worker and main thread.\n\n```js\n// Worker thread:\nself.addEventListener(\"message\", event => {\n  console.log(event.data);\n});\n// or use the setter:\n// self.onmessage = fn\n\n// if on the main thread\nworker.addEventListener(\"message\", event => {\n  console.log(event.data);\n});\n// or use the setter:\n// worker.onmessage = fn\n```\n\n## Terminating a worker\n\nA `Worker` instance terminates automatically once it's event loop has no work left to do. Attaching a `\"message\"` listener on the global or any `MessagePort`s will keep the event loop alive. To forcefully terminate a `Worker`, call `worker.terminate()`.\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href);\n\n// ...some time later\nworker.terminate();\n```\n\nThis will cause the worker's to exit as soon as possible.\n\n### `process.exit()`\n\nA worker can terminate itself with `process.exit()`. This does not terminate the main process. Like in Node.js, `process.on('beforeExit', callback)` and `process.on('exit', callback)` are emitted on the worker thread (and not on the main thread), and the exit code is passed to the `\"close\"` event.\n\n### `\"close\"`\n\nThe `\"close\"` event is emitted when a worker has been terminated. It can take some time for the worker to actually terminate, so this event is emitted when the worker has been marked as terminated. The `CloseEvent` will contain the exit code passed to `process.exit()`, or 0 if closed for other reasons.\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href);\n\nworker.addEventListener(\"close\", event => {\n  console.log(\"worker is being closed\");\n});\n```\n\nThis event does not exist in browsers.\n\n## Managing lifetime\n\nBy default, an active `Worker` will keep the main (spawning) process alive, so async tasks like `setTimeout` and promises will keep the process alive. Attaching `message` listeners will also keep the `Worker` alive.\n\n### `worker.unref()`\n\nTo stop a running worker from keeping the process alive, call `worker.unref()`. This decouples the lifetime of the worker to the lifetime of the main process, and is equivlent to what Node.js' `worker_threads` does.\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href);\nworker.unref();\n```\n\nNote: `worker.unref()` is not available in browers.\n\n### `worker.ref()`\n\nTo keep the process alive until the `Worker` terminates, call `worker.ref()`. A ref'd worker is the default behavior, and still needs something going on in the event loop (such as a `\"message\"` listener) for the worker to continue running.\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href);\nworker.unref();\n// later...\nworker.ref();\n```\n\nAlternatively, you can also pass an `options` object to `Worker`:\n\n```ts\nconst worker = new Worker(new URL(\"worker.ts\", import.meta.url).href, {\n  ref: false,\n});\n```\n\nNote: `worker.ref()` is not available in browers.\n\n## Memory usage with `smol`\n\nJavaScript instances can use a lot of memory. Bun's `Worker` supports a `smol` mode that reduces memory usage, at a cost of performance. To enable `smol` mode, pass `smol: true` to the `options` object in the `Worker` constructor.\n\n```js\nconst worker = new Worker(\"./i-am-smol.ts\", {\n  smol: true,\n});\n```\n\n{% details summary=\"What does `smol` mode actually do?\" %}\nSetting `smol: true` sets `JSC::HeapSize` to be `Small` instead of the default `Large`.\n{% /details %}\n"}]}
